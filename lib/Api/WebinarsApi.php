<?php
/**
 * WebinarsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Zoom Meeting API
 *
 * The Zoom Meeting APIs let developers to access information from Zoom. You can use this API to build private services or public applications on the [Zoom App Marketplace](http://marketplace.zoom.us). To learn how to get your credentials and create private/public applications, read our [JWT](/guides/auth/jwt) and [OAuth](/guides/auth/oauth) documentation.   All endpoints are available via `https` and are located at `api.zoom.us/v2/`. For example, to list all of an account's users, use the `https://api.zoom.us/v2/users/` endpoint.
 *
 * The version of the OpenAPI document: 2.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * WebinarsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class WebinarsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addBatchWebinarRegistrants
     *
     * Perform batch registration
     *
     * @param  string $webinar_id Unique identifier of the webinar. (required)
     * @param  \OpenAPI\Client\Model\AddBatchRegistrantsRequest $add_batch_registrants_request add_batch_registrants_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response
     */
    public function addBatchWebinarRegistrants($webinar_id, $add_batch_registrants_request = null)
    {
        list($response) = $this->addBatchWebinarRegistrantsWithHttpInfo($webinar_id, $add_batch_registrants_request);
        return $response;
    }

    /**
     * Operation addBatchWebinarRegistrantsWithHttpInfo
     *
     * Perform batch registration
     *
     * @param  string $webinar_id Unique identifier of the webinar. (required)
     * @param  \OpenAPI\Client\Model\AddBatchRegistrantsRequest $add_batch_registrants_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBatchWebinarRegistrantsWithHttpInfo($webinar_id, $add_batch_registrants_request = null)
    {
        $request = $this->addBatchWebinarRegistrantsRequest($webinar_id, $add_batch_registrants_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBatchWebinarRegistrantsAsync
     *
     * Perform batch registration
     *
     * @param  string $webinar_id Unique identifier of the webinar. (required)
     * @param  \OpenAPI\Client\Model\AddBatchRegistrantsRequest $add_batch_registrants_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBatchWebinarRegistrantsAsync($webinar_id, $add_batch_registrants_request = null)
    {
        return $this->addBatchWebinarRegistrantsAsyncWithHttpInfo($webinar_id, $add_batch_registrants_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBatchWebinarRegistrantsAsyncWithHttpInfo
     *
     * Perform batch registration
     *
     * @param  string $webinar_id Unique identifier of the webinar. (required)
     * @param  \OpenAPI\Client\Model\AddBatchRegistrantsRequest $add_batch_registrants_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBatchWebinarRegistrantsAsyncWithHttpInfo($webinar_id, $add_batch_registrants_request = null)
    {
        $returnType = '\OpenAPI\Client\Model\AddBatchWebinarRegistrants200Response';
        $request = $this->addBatchWebinarRegistrantsRequest($webinar_id, $add_batch_registrants_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBatchWebinarRegistrants'
     *
     * @param  string $webinar_id Unique identifier of the webinar. (required)
     * @param  \OpenAPI\Client\Model\AddBatchRegistrantsRequest $add_batch_registrants_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addBatchWebinarRegistrantsRequest($webinar_id, $add_batch_registrants_request = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling addBatchWebinarRegistrants'
            );
        }

        $resourcePath = '/webinars/{webinarId}/batch_registrants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($add_batch_registrants_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($add_batch_registrants_request));
            } else {
                $httpBody = $add_batch_registrants_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWebinarBrandingNameTag
     *
     * Create a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\CreateWebinarBrandingNameTagRequest $create_webinar_branding_name_tag_request create_webinar_branding_name_tag_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response
     */
    public function createWebinarBrandingNameTag($webinar_id, $create_webinar_branding_name_tag_request)
    {
        list($response) = $this->createWebinarBrandingNameTagWithHttpInfo($webinar_id, $create_webinar_branding_name_tag_request);
        return $response;
    }

    /**
     * Operation createWebinarBrandingNameTagWithHttpInfo
     *
     * Create a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\CreateWebinarBrandingNameTagRequest $create_webinar_branding_name_tag_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWebinarBrandingNameTagWithHttpInfo($webinar_id, $create_webinar_branding_name_tag_request)
    {
        $request = $this->createWebinarBrandingNameTagRequest($webinar_id, $create_webinar_branding_name_tag_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createWebinarBrandingNameTagAsync
     *
     * Create a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\CreateWebinarBrandingNameTagRequest $create_webinar_branding_name_tag_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebinarBrandingNameTagAsync($webinar_id, $create_webinar_branding_name_tag_request)
    {
        return $this->createWebinarBrandingNameTagAsyncWithHttpInfo($webinar_id, $create_webinar_branding_name_tag_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWebinarBrandingNameTagAsyncWithHttpInfo
     *
     * Create a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\CreateWebinarBrandingNameTagRequest $create_webinar_branding_name_tag_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebinarBrandingNameTagAsyncWithHttpInfo($webinar_id, $create_webinar_branding_name_tag_request)
    {
        $returnType = '\OpenAPI\Client\Model\CreateWebinarBrandingNameTag201Response';
        $request = $this->createWebinarBrandingNameTagRequest($webinar_id, $create_webinar_branding_name_tag_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWebinarBrandingNameTag'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\CreateWebinarBrandingNameTagRequest $create_webinar_branding_name_tag_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWebinarBrandingNameTagRequest($webinar_id, $create_webinar_branding_name_tag_request)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling createWebinarBrandingNameTag'
            );
        }
        // verify the required parameter 'create_webinar_branding_name_tag_request' is set
        if ($create_webinar_branding_name_tag_request === null || (is_array($create_webinar_branding_name_tag_request) && count($create_webinar_branding_name_tag_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_webinar_branding_name_tag_request when calling createWebinarBrandingNameTag'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/name_tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($create_webinar_branding_name_tag_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_webinar_branding_name_tag_request));
            } else {
                $httpBody = $create_webinar_branding_name_tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebinarBrandingNameTag
     *
     * Delete a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_ids A comma-separated list of the name tag IDs to delete. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebinarBrandingNameTag($webinar_id, $name_tag_ids = null)
    {
        $this->deleteWebinarBrandingNameTagWithHttpInfo($webinar_id, $name_tag_ids);
    }

    /**
     * Operation deleteWebinarBrandingNameTagWithHttpInfo
     *
     * Delete a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_ids A comma-separated list of the name tag IDs to delete. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebinarBrandingNameTagWithHttpInfo($webinar_id, $name_tag_ids = null)
    {
        $request = $this->deleteWebinarBrandingNameTagRequest($webinar_id, $name_tag_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebinarBrandingNameTagAsync
     *
     * Delete a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_ids A comma-separated list of the name tag IDs to delete. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarBrandingNameTagAsync($webinar_id, $name_tag_ids = null)
    {
        return $this->deleteWebinarBrandingNameTagAsyncWithHttpInfo($webinar_id, $name_tag_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebinarBrandingNameTagAsyncWithHttpInfo
     *
     * Delete a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_ids A comma-separated list of the name tag IDs to delete. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarBrandingNameTagAsyncWithHttpInfo($webinar_id, $name_tag_ids = null)
    {
        $returnType = '';
        $request = $this->deleteWebinarBrandingNameTagRequest($webinar_id, $name_tag_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebinarBrandingNameTag'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_ids A comma-separated list of the name tag IDs to delete. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebinarBrandingNameTagRequest($webinar_id, $name_tag_ids = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling deleteWebinarBrandingNameTag'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/name_tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name_tag_ids,
            'name_tag_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebinarBrandingVB
     *
     * Delete a webinar&#39;s branding Virtual Backgrounds
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $ids A comma-separated list of the Virtual Background file IDs to delete. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebinarBrandingVB($webinar_id, $ids = null)
    {
        $this->deleteWebinarBrandingVBWithHttpInfo($webinar_id, $ids);
    }

    /**
     * Operation deleteWebinarBrandingVBWithHttpInfo
     *
     * Delete a webinar&#39;s branding Virtual Backgrounds
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $ids A comma-separated list of the Virtual Background file IDs to delete. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebinarBrandingVBWithHttpInfo($webinar_id, $ids = null)
    {
        $request = $this->deleteWebinarBrandingVBRequest($webinar_id, $ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebinarBrandingVBAsync
     *
     * Delete a webinar&#39;s branding Virtual Backgrounds
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $ids A comma-separated list of the Virtual Background file IDs to delete. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarBrandingVBAsync($webinar_id, $ids = null)
    {
        return $this->deleteWebinarBrandingVBAsyncWithHttpInfo($webinar_id, $ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebinarBrandingVBAsyncWithHttpInfo
     *
     * Delete a webinar&#39;s branding Virtual Backgrounds
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $ids A comma-separated list of the Virtual Background file IDs to delete. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarBrandingVBAsyncWithHttpInfo($webinar_id, $ids = null)
    {
        $returnType = '';
        $request = $this->deleteWebinarBrandingVBRequest($webinar_id, $ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebinarBrandingVB'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $ids A comma-separated list of the Virtual Background file IDs to delete. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebinarBrandingVBRequest($webinar_id, $ids = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling deleteWebinarBrandingVB'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/virtual_backgrounds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebinarBrandingWallpaper
     *
     * Delete a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebinarBrandingWallpaper($webinar_id)
    {
        $this->deleteWebinarBrandingWallpaperWithHttpInfo($webinar_id);
    }

    /**
     * Operation deleteWebinarBrandingWallpaperWithHttpInfo
     *
     * Delete a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebinarBrandingWallpaperWithHttpInfo($webinar_id)
    {
        $request = $this->deleteWebinarBrandingWallpaperRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebinarBrandingWallpaperAsync
     *
     * Delete a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarBrandingWallpaperAsync($webinar_id)
    {
        return $this->deleteWebinarBrandingWallpaperAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebinarBrandingWallpaperAsyncWithHttpInfo
     *
     * Delete a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarBrandingWallpaperAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '';
        $request = $this->deleteWebinarBrandingWallpaperRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebinarBrandingWallpaper'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebinarBrandingWallpaperRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling deleteWebinarBrandingWallpaper'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/wallpaper';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebinarChatMessageById
     *
     * Delete a live webinar message
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $message_id The live webinar chat message&#39;s unique identifier (UUID), in base64-encoded format. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebinarChatMessageById($webinar_id, $message_id)
    {
        $this->deleteWebinarChatMessageByIdWithHttpInfo($webinar_id, $message_id);
    }

    /**
     * Operation deleteWebinarChatMessageByIdWithHttpInfo
     *
     * Delete a live webinar message
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $message_id The live webinar chat message&#39;s unique identifier (UUID), in base64-encoded format. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebinarChatMessageByIdWithHttpInfo($webinar_id, $message_id)
    {
        $request = $this->deleteWebinarChatMessageByIdRequest($webinar_id, $message_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebinarChatMessageByIdAsync
     *
     * Delete a live webinar message
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $message_id The live webinar chat message&#39;s unique identifier (UUID), in base64-encoded format. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarChatMessageByIdAsync($webinar_id, $message_id)
    {
        return $this->deleteWebinarChatMessageByIdAsyncWithHttpInfo($webinar_id, $message_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebinarChatMessageByIdAsyncWithHttpInfo
     *
     * Delete a live webinar message
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $message_id The live webinar chat message&#39;s unique identifier (UUID), in base64-encoded format. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarChatMessageByIdAsyncWithHttpInfo($webinar_id, $message_id)
    {
        $returnType = '';
        $request = $this->deleteWebinarChatMessageByIdRequest($webinar_id, $message_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebinarChatMessageById'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $message_id The live webinar chat message&#39;s unique identifier (UUID), in base64-encoded format. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebinarChatMessageByIdRequest($webinar_id, $message_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling deleteWebinarChatMessageById'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteWebinarChatMessageById'
            );
        }

        $resourcePath = '/live_webinars/{webinarId}/chat/messages/{messageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebinarRegistrant
     *
     * Delete a webinar registrant
     *
     * @param  int $webinar_id The webinar ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The webinar occurrence ID. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebinarRegistrant($webinar_id, $registrant_id, $occurrence_id = null)
    {
        $this->deleteWebinarRegistrantWithHttpInfo($webinar_id, $registrant_id, $occurrence_id);
    }

    /**
     * Operation deleteWebinarRegistrantWithHttpInfo
     *
     * Delete a webinar registrant
     *
     * @param  int $webinar_id The webinar ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The webinar occurrence ID. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebinarRegistrantWithHttpInfo($webinar_id, $registrant_id, $occurrence_id = null)
    {
        $request = $this->deleteWebinarRegistrantRequest($webinar_id, $registrant_id, $occurrence_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebinarRegistrantAsync
     *
     * Delete a webinar registrant
     *
     * @param  int $webinar_id The webinar ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarRegistrantAsync($webinar_id, $registrant_id, $occurrence_id = null)
    {
        return $this->deleteWebinarRegistrantAsyncWithHttpInfo($webinar_id, $registrant_id, $occurrence_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebinarRegistrantAsyncWithHttpInfo
     *
     * Delete a webinar registrant
     *
     * @param  int $webinar_id The webinar ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebinarRegistrantAsyncWithHttpInfo($webinar_id, $registrant_id, $occurrence_id = null)
    {
        $returnType = '';
        $request = $this->deleteWebinarRegistrantRequest($webinar_id, $registrant_id, $occurrence_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebinarRegistrant'
     *
     * @param  int $webinar_id The webinar ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebinarRegistrantRequest($webinar_id, $registrant_id, $occurrence_id = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling deleteWebinarRegistrant'
            );
        }
        // verify the required parameter 'registrant_id' is set
        if ($registrant_id === null || (is_array($registrant_id) && count($registrant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registrant_id when calling deleteWebinarRegistrant'
            );
        }

        $resourcePath = '/webinars/{webinarId}/registrants/{registrantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($registrant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrantId' . '}',
                ObjectSerializer::toPathValue($registrant_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTrackingSources
     *
     * Get webinar tracking sources
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetTrackingSources200Response
     */
    public function getTrackingSources($webinar_id)
    {
        list($response) = $this->getTrackingSourcesWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation getTrackingSourcesWithHttpInfo
     *
     * Get webinar tracking sources
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetTrackingSources200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrackingSourcesWithHttpInfo($webinar_id)
    {
        $request = $this->getTrackingSourcesRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetTrackingSources200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetTrackingSources200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetTrackingSources200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetTrackingSources200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetTrackingSources200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTrackingSourcesAsync
     *
     * Get webinar tracking sources
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingSourcesAsync($webinar_id)
    {
        return $this->getTrackingSourcesAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTrackingSourcesAsyncWithHttpInfo
     *
     * Get webinar tracking sources
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingSourcesAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\GetTrackingSources200Response';
        $request = $this->getTrackingSourcesRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrackingSources'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTrackingSourcesRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling getTrackingSources'
            );
        }

        $resourcePath = '/webinars/{webinarId}/tracking_sources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebinarBranding
     *
     * Get webinar&#39;s session branding
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetWebinarBranding200Response
     */
    public function getWebinarBranding($webinar_id)
    {
        list($response) = $this->getWebinarBrandingWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation getWebinarBrandingWithHttpInfo
     *
     * Get webinar&#39;s session branding
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetWebinarBranding200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebinarBrandingWithHttpInfo($webinar_id)
    {
        $request = $this->getWebinarBrandingRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetWebinarBranding200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetWebinarBranding200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetWebinarBranding200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetWebinarBranding200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetWebinarBranding200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebinarBrandingAsync
     *
     * Get webinar&#39;s session branding
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebinarBrandingAsync($webinar_id)
    {
        return $this->getWebinarBrandingAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebinarBrandingAsyncWithHttpInfo
     *
     * Get webinar&#39;s session branding
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebinarBrandingAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\GetWebinarBranding200Response';
        $request = $this->getWebinarBrandingRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebinarBranding'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebinarBrandingRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling getWebinarBranding'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebinarLiveStreamDetails
     *
     * Get live stream details
     *
     * @param  string $webinar_id The webinar&#39;s unique ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response
     */
    public function getWebinarLiveStreamDetails($webinar_id)
    {
        list($response) = $this->getWebinarLiveStreamDetailsWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation getWebinarLiveStreamDetailsWithHttpInfo
     *
     * Get live stream details
     *
     * @param  string $webinar_id The webinar&#39;s unique ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebinarLiveStreamDetailsWithHttpInfo($webinar_id)
    {
        $request = $this->getWebinarLiveStreamDetailsRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebinarLiveStreamDetailsAsync
     *
     * Get live stream details
     *
     * @param  string $webinar_id The webinar&#39;s unique ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebinarLiveStreamDetailsAsync($webinar_id)
    {
        return $this->getWebinarLiveStreamDetailsAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebinarLiveStreamDetailsAsyncWithHttpInfo
     *
     * Get live stream details
     *
     * @param  string $webinar_id The webinar&#39;s unique ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebinarLiveStreamDetailsAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\GetWebinarLiveStreamDetails200Response';
        $request = $this->getWebinarLiveStreamDetailsRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebinarLiveStreamDetails'
     *
     * @param  string $webinar_id The webinar&#39;s unique ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebinarLiveStreamDetailsRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling getWebinarLiveStreamDetails'
            );
        }

        $resourcePath = '/webinars/{webinarId}/livestream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPastWebinarPollResults
     *
     * List past webinar poll results
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListPastWebinarPollResults200Response
     */
    public function listPastWebinarPollResults($webinar_id)
    {
        list($response) = $this->listPastWebinarPollResultsWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation listPastWebinarPollResultsWithHttpInfo
     *
     * List past webinar poll results
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListPastWebinarPollResults200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPastWebinarPollResultsWithHttpInfo($webinar_id)
    {
        $request = $this->listPastWebinarPollResultsRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListPastWebinarPollResults200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListPastWebinarPollResults200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListPastWebinarPollResults200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListPastWebinarPollResults200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListPastWebinarPollResults200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPastWebinarPollResultsAsync
     *
     * List past webinar poll results
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPastWebinarPollResultsAsync($webinar_id)
    {
        return $this->listPastWebinarPollResultsAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPastWebinarPollResultsAsyncWithHttpInfo
     *
     * List past webinar poll results
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPastWebinarPollResultsAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\ListPastWebinarPollResults200Response';
        $request = $this->listPastWebinarPollResultsRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPastWebinarPollResults'
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPastWebinarPollResultsRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling listPastWebinarPollResults'
            );
        }

        $resourcePath = '/past_webinars/{webinarId}/polls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPastWebinarQA
     *
     * List Q&amp;A of past webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListPastWebinarQA200Response
     */
    public function listPastWebinarQA($webinar_id)
    {
        list($response) = $this->listPastWebinarQAWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation listPastWebinarQAWithHttpInfo
     *
     * List Q&amp;A of past webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListPastWebinarQA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPastWebinarQAWithHttpInfo($webinar_id)
    {
        $request = $this->listPastWebinarQARequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListPastWebinarQA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListPastWebinarQA200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListPastWebinarQA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListPastWebinarQA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListPastWebinarQA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPastWebinarQAAsync
     *
     * List Q&amp;A of past webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPastWebinarQAAsync($webinar_id)
    {
        return $this->listPastWebinarQAAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPastWebinarQAAsyncWithHttpInfo
     *
     * List Q&amp;A of past webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPastWebinarQAAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\ListPastWebinarQA200Response';
        $request = $this->listPastWebinarQARequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPastWebinarQA'
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPastWebinarQARequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling listPastWebinarQA'
            );
        }

        $resourcePath = '/past_webinars/{webinarId}/qa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebinarParticipants
     *
     * List webinar participants
     *
     * @param  string $webinar_id The webinar&#39;s ID. To get this value, use the [**List webinars**](/docs/api-reference/zoom-api/methods#operation/webinars) API. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListWebinarParticipants200Response
     */
    public function listWebinarParticipants($webinar_id, $page_size = 30, $next_page_token = null)
    {
        list($response) = $this->listWebinarParticipantsWithHttpInfo($webinar_id, $page_size, $next_page_token);
        return $response;
    }

    /**
     * Operation listWebinarParticipantsWithHttpInfo
     *
     * List webinar participants
     *
     * @param  string $webinar_id The webinar&#39;s ID. To get this value, use the [**List webinars**](/docs/api-reference/zoom-api/methods#operation/webinars) API. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListWebinarParticipants200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebinarParticipantsWithHttpInfo($webinar_id, $page_size = 30, $next_page_token = null)
    {
        $request = $this->listWebinarParticipantsRequest($webinar_id, $page_size, $next_page_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListWebinarParticipants200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListWebinarParticipants200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListWebinarParticipants200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListWebinarParticipants200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListWebinarParticipants200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebinarParticipantsAsync
     *
     * List webinar participants
     *
     * @param  string $webinar_id The webinar&#39;s ID. To get this value, use the [**List webinars**](/docs/api-reference/zoom-api/methods#operation/webinars) API. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebinarParticipantsAsync($webinar_id, $page_size = 30, $next_page_token = null)
    {
        return $this->listWebinarParticipantsAsyncWithHttpInfo($webinar_id, $page_size, $next_page_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebinarParticipantsAsyncWithHttpInfo
     *
     * List webinar participants
     *
     * @param  string $webinar_id The webinar&#39;s ID. To get this value, use the [**List webinars**](/docs/api-reference/zoom-api/methods#operation/webinars) API. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebinarParticipantsAsyncWithHttpInfo($webinar_id, $page_size = 30, $next_page_token = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListWebinarParticipants200Response';
        $request = $this->listWebinarParticipantsRequest($webinar_id, $page_size, $next_page_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebinarParticipants'
     *
     * @param  string $webinar_id The webinar&#39;s ID. To get this value, use the [**List webinars**](/docs/api-reference/zoom-api/methods#operation/webinars) API. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listWebinarParticipantsRequest($webinar_id, $page_size = 30, $next_page_token = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling listWebinarParticipants'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling WebinarsApi.listWebinarParticipants, must be smaller than or equal to 300.');
        }


        $resourcePath = '/past_webinars/{webinarId}/participants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebinarTemplates
     *
     * List webinar templates
     *
     * @param  string $user_id The user&#39;s ID. To get a user&#39;s ID, use the [**List users**](/docs/api-reference/zoom-api/ma#operation/users) API. For user-level apps, pass the &#x60;me&#x60; value instead of the user ID value. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListWebinarTemplates200Response
     */
    public function listWebinarTemplates($user_id)
    {
        list($response) = $this->listWebinarTemplatesWithHttpInfo($user_id);
        return $response;
    }

    /**
     * Operation listWebinarTemplatesWithHttpInfo
     *
     * List webinar templates
     *
     * @param  string $user_id The user&#39;s ID. To get a user&#39;s ID, use the [**List users**](/docs/api-reference/zoom-api/ma#operation/users) API. For user-level apps, pass the &#x60;me&#x60; value instead of the user ID value. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListWebinarTemplates200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebinarTemplatesWithHttpInfo($user_id)
    {
        $request = $this->listWebinarTemplatesRequest($user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListWebinarTemplates200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListWebinarTemplates200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListWebinarTemplates200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListWebinarTemplates200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListWebinarTemplates200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebinarTemplatesAsync
     *
     * List webinar templates
     *
     * @param  string $user_id The user&#39;s ID. To get a user&#39;s ID, use the [**List users**](/docs/api-reference/zoom-api/ma#operation/users) API. For user-level apps, pass the &#x60;me&#x60; value instead of the user ID value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebinarTemplatesAsync($user_id)
    {
        return $this->listWebinarTemplatesAsyncWithHttpInfo($user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebinarTemplatesAsyncWithHttpInfo
     *
     * List webinar templates
     *
     * @param  string $user_id The user&#39;s ID. To get a user&#39;s ID, use the [**List users**](/docs/api-reference/zoom-api/ma#operation/users) API. For user-level apps, pass the &#x60;me&#x60; value instead of the user ID value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebinarTemplatesAsyncWithHttpInfo($user_id)
    {
        $returnType = '\OpenAPI\Client\Model\ListWebinarTemplates200Response';
        $request = $this->listWebinarTemplatesRequest($user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebinarTemplates'
     *
     * @param  string $user_id The user&#39;s ID. To get a user&#39;s ID, use the [**List users**](/docs/api-reference/zoom-api/ma#operation/users) API. For user-level apps, pass the &#x60;me&#x60; value instead of the user ID value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listWebinarTemplatesRequest($user_id)
    {
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling listWebinarTemplates'
            );
        }

        $resourcePath = '/users/{userId}/webinar_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pastWebinars
     *
     * List past webinar instances
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarInstances
     */
    public function pastWebinars($webinar_id)
    {
        list($response) = $this->pastWebinarsWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation pastWebinarsWithHttpInfo
     *
     * List past webinar instances
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarInstances, HTTP status code, HTTP response headers (array of strings)
     */
    public function pastWebinarsWithHttpInfo($webinar_id)
    {
        $request = $this->pastWebinarsRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarInstances' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarInstances' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarInstances', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarInstances';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarInstances',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pastWebinarsAsync
     *
     * List past webinar instances
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pastWebinarsAsync($webinar_id)
    {
        return $this->pastWebinarsAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pastWebinarsAsyncWithHttpInfo
     *
     * List past webinar instances
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pastWebinarsAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarInstances';
        $request = $this->pastWebinarsRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pastWebinars'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pastWebinarsRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling pastWebinars'
            );
        }

        $resourcePath = '/past_webinars/{webinarId}/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setWebinarBrandingVB
     *
     * Set webinar&#39;s default branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $id The Virtual Background file ID to update. (optional)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setWebinarBrandingVB($webinar_id, $id = null, $set_default_for_all_panelists = null)
    {
        $this->setWebinarBrandingVBWithHttpInfo($webinar_id, $id, $set_default_for_all_panelists);
    }

    /**
     * Operation setWebinarBrandingVBWithHttpInfo
     *
     * Set webinar&#39;s default branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $id The Virtual Background file ID to update. (optional)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setWebinarBrandingVBWithHttpInfo($webinar_id, $id = null, $set_default_for_all_panelists = null)
    {
        $request = $this->setWebinarBrandingVBRequest($webinar_id, $id, $set_default_for_all_panelists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setWebinarBrandingVBAsync
     *
     * Set webinar&#39;s default branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $id The Virtual Background file ID to update. (optional)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setWebinarBrandingVBAsync($webinar_id, $id = null, $set_default_for_all_panelists = null)
    {
        return $this->setWebinarBrandingVBAsyncWithHttpInfo($webinar_id, $id, $set_default_for_all_panelists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setWebinarBrandingVBAsyncWithHttpInfo
     *
     * Set webinar&#39;s default branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $id The Virtual Background file ID to update. (optional)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setWebinarBrandingVBAsyncWithHttpInfo($webinar_id, $id = null, $set_default_for_all_panelists = null)
    {
        $returnType = '';
        $request = $this->setWebinarBrandingVBRequest($webinar_id, $id, $set_default_for_all_panelists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setWebinarBrandingVB'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $id The Virtual Background file ID to update. (optional)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setWebinarBrandingVBRequest($webinar_id, $id = null, $set_default_for_all_panelists = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling setWebinarBrandingVB'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/virtual_backgrounds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $set_default_for_all_panelists,
            'set_default_for_all_panelists', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateWebinarBrandingNameTag
     *
     * Update a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_id The name tag&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateWebinarBrandingNameTagRequest $update_webinar_branding_name_tag_request update_webinar_branding_name_tag_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateWebinarBrandingNameTag($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request)
    {
        $this->updateWebinarBrandingNameTagWithHttpInfo($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request);
    }

    /**
     * Operation updateWebinarBrandingNameTagWithHttpInfo
     *
     * Update a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_id The name tag&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateWebinarBrandingNameTagRequest $update_webinar_branding_name_tag_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWebinarBrandingNameTagWithHttpInfo($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request)
    {
        $request = $this->updateWebinarBrandingNameTagRequest($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateWebinarBrandingNameTagAsync
     *
     * Update a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_id The name tag&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateWebinarBrandingNameTagRequest $update_webinar_branding_name_tag_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebinarBrandingNameTagAsync($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request)
    {
        return $this->updateWebinarBrandingNameTagAsyncWithHttpInfo($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateWebinarBrandingNameTagAsyncWithHttpInfo
     *
     * Update a webinar&#39;s branding name tag
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_id The name tag&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateWebinarBrandingNameTagRequest $update_webinar_branding_name_tag_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebinarBrandingNameTagAsyncWithHttpInfo($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request)
    {
        $returnType = '';
        $request = $this->updateWebinarBrandingNameTagRequest($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateWebinarBrandingNameTag'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $name_tag_id The name tag&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateWebinarBrandingNameTagRequest $update_webinar_branding_name_tag_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateWebinarBrandingNameTagRequest($webinar_id, $name_tag_id, $update_webinar_branding_name_tag_request)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling updateWebinarBrandingNameTag'
            );
        }
        // verify the required parameter 'name_tag_id' is set
        if ($name_tag_id === null || (is_array($name_tag_id) && count($name_tag_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name_tag_id when calling updateWebinarBrandingNameTag'
            );
        }
        // verify the required parameter 'update_webinar_branding_name_tag_request' is set
        if ($update_webinar_branding_name_tag_request === null || (is_array($update_webinar_branding_name_tag_request) && count($update_webinar_branding_name_tag_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_webinar_branding_name_tag_request when calling updateWebinarBrandingNameTag'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/name_tags/{nameTagId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($name_tag_id !== null) {
            $resourcePath = str_replace(
                '{' . 'nameTagId' . '}',
                ObjectSerializer::toPathValue($name_tag_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_webinar_branding_name_tag_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_webinar_branding_name_tag_request));
            } else {
                $httpBody = $update_webinar_branding_name_tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadWebinarBrandingVB
     *
     * Upload a webinar&#39;s branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The Virtual Background&#39;s file path, in binary format. (required)
     * @param  bool $default Whether set the file as the default Virtual Background file. (optional, default to false)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UploadWebinarBrandingVB201Response
     */
    public function uploadWebinarBrandingVB($webinar_id, $file, $default = false, $set_default_for_all_panelists = true)
    {
        list($response) = $this->uploadWebinarBrandingVBWithHttpInfo($webinar_id, $file, $default, $set_default_for_all_panelists);
        return $response;
    }

    /**
     * Operation uploadWebinarBrandingVBWithHttpInfo
     *
     * Upload a webinar&#39;s branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The Virtual Background&#39;s file path, in binary format. (required)
     * @param  bool $default Whether set the file as the default Virtual Background file. (optional, default to false)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UploadWebinarBrandingVB201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadWebinarBrandingVBWithHttpInfo($webinar_id, $file, $default = false, $set_default_for_all_panelists = true)
    {
        $request = $this->uploadWebinarBrandingVBRequest($webinar_id, $file, $default, $set_default_for_all_panelists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\UploadWebinarBrandingVB201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UploadWebinarBrandingVB201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UploadWebinarBrandingVB201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\UploadWebinarBrandingVB201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UploadWebinarBrandingVB201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadWebinarBrandingVBAsync
     *
     * Upload a webinar&#39;s branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The Virtual Background&#39;s file path, in binary format. (required)
     * @param  bool $default Whether set the file as the default Virtual Background file. (optional, default to false)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadWebinarBrandingVBAsync($webinar_id, $file, $default = false, $set_default_for_all_panelists = true)
    {
        return $this->uploadWebinarBrandingVBAsyncWithHttpInfo($webinar_id, $file, $default, $set_default_for_all_panelists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadWebinarBrandingVBAsyncWithHttpInfo
     *
     * Upload a webinar&#39;s branding Virtual Background
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The Virtual Background&#39;s file path, in binary format. (required)
     * @param  bool $default Whether set the file as the default Virtual Background file. (optional, default to false)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadWebinarBrandingVBAsyncWithHttpInfo($webinar_id, $file, $default = false, $set_default_for_all_panelists = true)
    {
        $returnType = '\OpenAPI\Client\Model\UploadWebinarBrandingVB201Response';
        $request = $this->uploadWebinarBrandingVBRequest($webinar_id, $file, $default, $set_default_for_all_panelists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadWebinarBrandingVB'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The Virtual Background&#39;s file path, in binary format. (required)
     * @param  bool $default Whether set the file as the default Virtual Background file. (optional, default to false)
     * @param  bool $set_default_for_all_panelists Whether to set the Virtual Background file as the new default for all panelists. This includes panelists not currently assigned a default Virtual Background. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadWebinarBrandingVBRequest($webinar_id, $file, $default = false, $set_default_for_all_panelists = true)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling uploadWebinarBrandingVB'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadWebinarBrandingVB'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/virtual_backgrounds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($default !== null) {
            $formParams['default'] = ObjectSerializer::toFormValue($default);
        }
        // form params
        if ($set_default_for_all_panelists !== null) {
            $formParams['set_default_for_all_panelists'] = ObjectSerializer::toFormValue($set_default_for_all_panelists);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadWebinarBrandingWallpaper
     *
     * Upload a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The wallpaper&#39;s file path, in binary format. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response
     */
    public function uploadWebinarBrandingWallpaper($webinar_id, $file)
    {
        list($response) = $this->uploadWebinarBrandingWallpaperWithHttpInfo($webinar_id, $file);
        return $response;
    }

    /**
     * Operation uploadWebinarBrandingWallpaperWithHttpInfo
     *
     * Upload a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The wallpaper&#39;s file path, in binary format. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadWebinarBrandingWallpaperWithHttpInfo($webinar_id, $file)
    {
        $request = $this->uploadWebinarBrandingWallpaperRequest($webinar_id, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadWebinarBrandingWallpaperAsync
     *
     * Upload a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The wallpaper&#39;s file path, in binary format. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadWebinarBrandingWallpaperAsync($webinar_id, $file)
    {
        return $this->uploadWebinarBrandingWallpaperAsyncWithHttpInfo($webinar_id, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadWebinarBrandingWallpaperAsyncWithHttpInfo
     *
     * Upload a webinar&#39;s branding wallpaper
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The wallpaper&#39;s file path, in binary format. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadWebinarBrandingWallpaperAsyncWithHttpInfo($webinar_id, $file)
    {
        $returnType = '\OpenAPI\Client\Model\UploadWebinarBrandingWallpaper201Response';
        $request = $this->uploadWebinarBrandingWallpaperRequest($webinar_id, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadWebinarBrandingWallpaper'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \SplFileObject $file The wallpaper&#39;s file path, in binary format. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadWebinarBrandingWallpaperRequest($webinar_id, $file)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling uploadWebinarBrandingWallpaper'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadWebinarBrandingWallpaper'
            );
        }

        $resourcePath = '/webinars/{webinarId}/branding/wallpaper';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinar
     *
     * Get a webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID). (required)
     * @param  string $occurrence_id Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences. When you create a recurring Webinar using [**Create a webinar**](/docs/api-reference/zoom-api/methods#operation/webinarCreate) API, you can retrieve the Occurrence ID from the response of the API call. (optional)
     * @param  bool $show_previous_occurrences Set the value of this field to &#x60;true&#x60; if you would like to view Webinar details of all previous occurrences of a recurring Webinar. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Webinar200Response
     */
    public function webinar($webinar_id, $occurrence_id = null, $show_previous_occurrences = null)
    {
        list($response) = $this->webinarWithHttpInfo($webinar_id, $occurrence_id, $show_previous_occurrences);
        return $response;
    }

    /**
     * Operation webinarWithHttpInfo
     *
     * Get a webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID). (required)
     * @param  string $occurrence_id Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences. When you create a recurring Webinar using [**Create a webinar**](/docs/api-reference/zoom-api/methods#operation/webinarCreate) API, you can retrieve the Occurrence ID from the response of the API call. (optional)
     * @param  bool $show_previous_occurrences Set the value of this field to &#x60;true&#x60; if you would like to view Webinar details of all previous occurrences of a recurring Webinar. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Webinar200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarWithHttpInfo($webinar_id, $occurrence_id = null, $show_previous_occurrences = null)
    {
        $request = $this->webinarRequest($webinar_id, $occurrence_id, $show_previous_occurrences);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Webinar200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Webinar200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Webinar200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Webinar200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Webinar200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarAsync
     *
     * Get a webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID). (required)
     * @param  string $occurrence_id Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences. When you create a recurring Webinar using [**Create a webinar**](/docs/api-reference/zoom-api/methods#operation/webinarCreate) API, you can retrieve the Occurrence ID from the response of the API call. (optional)
     * @param  bool $show_previous_occurrences Set the value of this field to &#x60;true&#x60; if you would like to view Webinar details of all previous occurrences of a recurring Webinar. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarAsync($webinar_id, $occurrence_id = null, $show_previous_occurrences = null)
    {
        return $this->webinarAsyncWithHttpInfo($webinar_id, $occurrence_id, $show_previous_occurrences)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarAsyncWithHttpInfo
     *
     * Get a webinar
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID). (required)
     * @param  string $occurrence_id Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences. When you create a recurring Webinar using [**Create a webinar**](/docs/api-reference/zoom-api/methods#operation/webinarCreate) API, you can retrieve the Occurrence ID from the response of the API call. (optional)
     * @param  bool $show_previous_occurrences Set the value of this field to &#x60;true&#x60; if you would like to view Webinar details of all previous occurrences of a recurring Webinar. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarAsyncWithHttpInfo($webinar_id, $occurrence_id = null, $show_previous_occurrences = null)
    {
        $returnType = '\OpenAPI\Client\Model\Webinar200Response';
        $request = $this->webinarRequest($webinar_id, $occurrence_id, $show_previous_occurrences);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinar'
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID). (required)
     * @param  string $occurrence_id Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences. When you create a recurring Webinar using [**Create a webinar**](/docs/api-reference/zoom-api/methods#operation/webinarCreate) API, you can retrieve the Occurrence ID from the response of the API call. (optional)
     * @param  bool $show_previous_occurrences Set the value of this field to &#x60;true&#x60; if you would like to view Webinar details of all previous occurrences of a recurring Webinar. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarRequest($webinar_id, $occurrence_id = null, $show_previous_occurrences = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinar'
            );
        }

        $resourcePath = '/webinars/{webinarId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_previous_occurrences,
            'show_previous_occurrences', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarAbsentees
     *
     * Get webinar absentees
     *
     * @param  string $webinar_uuid The Webinar UUID. Each Webinar instance will generate its own Webinar UUID (i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Please double encode your UUID when using it for API calls if the UUID begins with a &#39;/&#39; or contains &#39;//&#39; in it. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarRegistrantList
     */
    public function webinarAbsentees($webinar_uuid, $occurrence_id = null, $page_size = 30, $next_page_token = null)
    {
        list($response) = $this->webinarAbsenteesWithHttpInfo($webinar_uuid, $occurrence_id, $page_size, $next_page_token);
        return $response;
    }

    /**
     * Operation webinarAbsenteesWithHttpInfo
     *
     * Get webinar absentees
     *
     * @param  string $webinar_uuid The Webinar UUID. Each Webinar instance will generate its own Webinar UUID (i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Please double encode your UUID when using it for API calls if the UUID begins with a &#39;/&#39; or contains &#39;//&#39; in it. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarRegistrantList, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarAbsenteesWithHttpInfo($webinar_uuid, $occurrence_id = null, $page_size = 30, $next_page_token = null)
    {
        $request = $this->webinarAbsenteesRequest($webinar_uuid, $occurrence_id, $page_size, $next_page_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarRegistrantList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarRegistrantList' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarRegistrantList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarRegistrantList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarRegistrantList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarAbsenteesAsync
     *
     * Get webinar absentees
     *
     * @param  string $webinar_uuid The Webinar UUID. Each Webinar instance will generate its own Webinar UUID (i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Please double encode your UUID when using it for API calls if the UUID begins with a &#39;/&#39; or contains &#39;//&#39; in it. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarAbsenteesAsync($webinar_uuid, $occurrence_id = null, $page_size = 30, $next_page_token = null)
    {
        return $this->webinarAbsenteesAsyncWithHttpInfo($webinar_uuid, $occurrence_id, $page_size, $next_page_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarAbsenteesAsyncWithHttpInfo
     *
     * Get webinar absentees
     *
     * @param  string $webinar_uuid The Webinar UUID. Each Webinar instance will generate its own Webinar UUID (i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Please double encode your UUID when using it for API calls if the UUID begins with a &#39;/&#39; or contains &#39;//&#39; in it. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarAbsenteesAsyncWithHttpInfo($webinar_uuid, $occurrence_id = null, $page_size = 30, $next_page_token = null)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarRegistrantList';
        $request = $this->webinarAbsenteesRequest($webinar_uuid, $occurrence_id, $page_size, $next_page_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarAbsentees'
     *
     * @param  string $webinar_uuid The Webinar UUID. Each Webinar instance will generate its own Webinar UUID (i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Please double encode your UUID when using it for API calls if the UUID begins with a &#39;/&#39; or contains &#39;//&#39; in it. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarAbsenteesRequest($webinar_uuid, $occurrence_id = null, $page_size = 30, $next_page_token = null)
    {
        // verify the required parameter 'webinar_uuid' is set
        if ($webinar_uuid === null || (is_array($webinar_uuid) && count($webinar_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_uuid when calling webinarAbsentees'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling WebinarsApi.webinarAbsentees, must be smaller than or equal to 300.');
        }


        $resourcePath = '/past_webinars/{WebinarUUID}/absentees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'WebinarUUID' . '}',
                ObjectSerializer::toPathValue($webinar_uuid),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarCreate
     *
     * Create a webinar
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \OpenAPI\Client\Model\WebinarCreateRequest $webinar_create_request webinar_create_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarCreate201Response
     */
    public function webinarCreate($user_id, $webinar_create_request)
    {
        list($response) = $this->webinarCreateWithHttpInfo($user_id, $webinar_create_request);
        return $response;
    }

    /**
     * Operation webinarCreateWithHttpInfo
     *
     * Create a webinar
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \OpenAPI\Client\Model\WebinarCreateRequest $webinar_create_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarCreate201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarCreateWithHttpInfo($user_id, $webinar_create_request)
    {
        $request = $this->webinarCreateRequest($user_id, $webinar_create_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\WebinarCreate201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarCreate201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarCreate201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarCreate201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarCreate201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarCreateAsync
     *
     * Create a webinar
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \OpenAPI\Client\Model\WebinarCreateRequest $webinar_create_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarCreateAsync($user_id, $webinar_create_request)
    {
        return $this->webinarCreateAsyncWithHttpInfo($user_id, $webinar_create_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarCreateAsyncWithHttpInfo
     *
     * Create a webinar
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \OpenAPI\Client\Model\WebinarCreateRequest $webinar_create_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarCreateAsyncWithHttpInfo($user_id, $webinar_create_request)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarCreate201Response';
        $request = $this->webinarCreateRequest($user_id, $webinar_create_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarCreate'
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \OpenAPI\Client\Model\WebinarCreateRequest $webinar_create_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarCreateRequest($user_id, $webinar_create_request)
    {
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling webinarCreate'
            );
        }
        // verify the required parameter 'webinar_create_request' is set
        if ($webinar_create_request === null || (is_array($webinar_create_request) && count($webinar_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_create_request when calling webinarCreate'
            );
        }

        $resourcePath = '/users/{userId}/webinars';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_create_request));
            } else {
                $httpBody = $webinar_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarDelete
     *
     * Delete a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  bool $cancel_webinar_reminder &#x60;true&#x60;: Notify panelists and registrants about the webinar cancellation via email.   &#x60;false&#x60;: Do not send any email notification to webinar registrants and panelists.   The default value of this field is &#x60;false&#x60;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarDelete($webinar_id, $occurrence_id = null, $cancel_webinar_reminder = null)
    {
        $this->webinarDeleteWithHttpInfo($webinar_id, $occurrence_id, $cancel_webinar_reminder);
    }

    /**
     * Operation webinarDeleteWithHttpInfo
     *
     * Delete a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  bool $cancel_webinar_reminder &#x60;true&#x60;: Notify panelists and registrants about the webinar cancellation via email.   &#x60;false&#x60;: Do not send any email notification to webinar registrants and panelists.   The default value of this field is &#x60;false&#x60;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarDeleteWithHttpInfo($webinar_id, $occurrence_id = null, $cancel_webinar_reminder = null)
    {
        $request = $this->webinarDeleteRequest($webinar_id, $occurrence_id, $cancel_webinar_reminder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarDeleteAsync
     *
     * Delete a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  bool $cancel_webinar_reminder &#x60;true&#x60;: Notify panelists and registrants about the webinar cancellation via email.   &#x60;false&#x60;: Do not send any email notification to webinar registrants and panelists.   The default value of this field is &#x60;false&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarDeleteAsync($webinar_id, $occurrence_id = null, $cancel_webinar_reminder = null)
    {
        return $this->webinarDeleteAsyncWithHttpInfo($webinar_id, $occurrence_id, $cancel_webinar_reminder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarDeleteAsyncWithHttpInfo
     *
     * Delete a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  bool $cancel_webinar_reminder &#x60;true&#x60;: Notify panelists and registrants about the webinar cancellation via email.   &#x60;false&#x60;: Do not send any email notification to webinar registrants and panelists.   The default value of this field is &#x60;false&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarDeleteAsyncWithHttpInfo($webinar_id, $occurrence_id = null, $cancel_webinar_reminder = null)
    {
        $returnType = '';
        $request = $this->webinarDeleteRequest($webinar_id, $occurrence_id, $cancel_webinar_reminder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarDelete'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  bool $cancel_webinar_reminder &#x60;true&#x60;: Notify panelists and registrants about the webinar cancellation via email.   &#x60;false&#x60;: Do not send any email notification to webinar registrants and panelists.   The default value of this field is &#x60;false&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarDeleteRequest($webinar_id, $occurrence_id = null, $cancel_webinar_reminder = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarDelete'
            );
        }

        $resourcePath = '/webinars/{webinarId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cancel_webinar_reminder,
            'cancel_webinar_reminder', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarInviteLinksCreate
     *
     * Create webinar&#39;s invite links
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingInviteLinksCreateRequest $meeting_invite_links_create_request Webinar invite link object (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MeetingInviteLinksCreate201Response
     */
    public function webinarInviteLinksCreate($webinar_id, $meeting_invite_links_create_request)
    {
        list($response) = $this->webinarInviteLinksCreateWithHttpInfo($webinar_id, $meeting_invite_links_create_request);
        return $response;
    }

    /**
     * Operation webinarInviteLinksCreateWithHttpInfo
     *
     * Create webinar&#39;s invite links
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingInviteLinksCreateRequest $meeting_invite_links_create_request Webinar invite link object (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MeetingInviteLinksCreate201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarInviteLinksCreateWithHttpInfo($webinar_id, $meeting_invite_links_create_request)
    {
        $request = $this->webinarInviteLinksCreateRequest($webinar_id, $meeting_invite_links_create_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\MeetingInviteLinksCreate201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MeetingInviteLinksCreate201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MeetingInviteLinksCreate201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MeetingInviteLinksCreate201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MeetingInviteLinksCreate201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarInviteLinksCreateAsync
     *
     * Create webinar&#39;s invite links
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingInviteLinksCreateRequest $meeting_invite_links_create_request Webinar invite link object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarInviteLinksCreateAsync($webinar_id, $meeting_invite_links_create_request)
    {
        return $this->webinarInviteLinksCreateAsyncWithHttpInfo($webinar_id, $meeting_invite_links_create_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarInviteLinksCreateAsyncWithHttpInfo
     *
     * Create webinar&#39;s invite links
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingInviteLinksCreateRequest $meeting_invite_links_create_request Webinar invite link object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarInviteLinksCreateAsyncWithHttpInfo($webinar_id, $meeting_invite_links_create_request)
    {
        $returnType = '\OpenAPI\Client\Model\MeetingInviteLinksCreate201Response';
        $request = $this->webinarInviteLinksCreateRequest($webinar_id, $meeting_invite_links_create_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarInviteLinksCreate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingInviteLinksCreateRequest $meeting_invite_links_create_request Webinar invite link object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarInviteLinksCreateRequest($webinar_id, $meeting_invite_links_create_request)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarInviteLinksCreate'
            );
        }
        // verify the required parameter 'meeting_invite_links_create_request' is set
        if ($meeting_invite_links_create_request === null || (is_array($meeting_invite_links_create_request) && count($meeting_invite_links_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meeting_invite_links_create_request when calling webinarInviteLinksCreate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/invite_links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($meeting_invite_links_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($meeting_invite_links_create_request));
            } else {
                $httpBody = $meeting_invite_links_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarLiveStreamStatusUpdate
     *
     * Update Live Stream Status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStreamStatus $webinar_live_stream_status Webinar (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarLiveStreamStatusUpdate($webinar_id, $webinar_live_stream_status)
    {
        $this->webinarLiveStreamStatusUpdateWithHttpInfo($webinar_id, $webinar_live_stream_status);
    }

    /**
     * Operation webinarLiveStreamStatusUpdateWithHttpInfo
     *
     * Update Live Stream Status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStreamStatus $webinar_live_stream_status Webinar (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarLiveStreamStatusUpdateWithHttpInfo($webinar_id, $webinar_live_stream_status)
    {
        $request = $this->webinarLiveStreamStatusUpdateRequest($webinar_id, $webinar_live_stream_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarLiveStreamStatusUpdateAsync
     *
     * Update Live Stream Status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStreamStatus $webinar_live_stream_status Webinar (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarLiveStreamStatusUpdateAsync($webinar_id, $webinar_live_stream_status)
    {
        return $this->webinarLiveStreamStatusUpdateAsyncWithHttpInfo($webinar_id, $webinar_live_stream_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarLiveStreamStatusUpdateAsyncWithHttpInfo
     *
     * Update Live Stream Status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStreamStatus $webinar_live_stream_status Webinar (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarLiveStreamStatusUpdateAsyncWithHttpInfo($webinar_id, $webinar_live_stream_status)
    {
        $returnType = '';
        $request = $this->webinarLiveStreamStatusUpdateRequest($webinar_id, $webinar_live_stream_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarLiveStreamStatusUpdate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStreamStatus $webinar_live_stream_status Webinar (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarLiveStreamStatusUpdateRequest($webinar_id, $webinar_live_stream_status)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarLiveStreamStatusUpdate'
            );
        }
        // verify the required parameter 'webinar_live_stream_status' is set
        if ($webinar_live_stream_status === null || (is_array($webinar_live_stream_status) && count($webinar_live_stream_status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_live_stream_status when calling webinarLiveStreamStatusUpdate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/livestream/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_live_stream_status)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_live_stream_status));
            } else {
                $httpBody = $webinar_live_stream_status;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarLiveStreamUpdate
     *
     * Update a live stream
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStream $webinar_live_stream Webinar (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarLiveStreamUpdate($webinar_id, $webinar_live_stream)
    {
        $this->webinarLiveStreamUpdateWithHttpInfo($webinar_id, $webinar_live_stream);
    }

    /**
     * Operation webinarLiveStreamUpdateWithHttpInfo
     *
     * Update a live stream
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStream $webinar_live_stream Webinar (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarLiveStreamUpdateWithHttpInfo($webinar_id, $webinar_live_stream)
    {
        $request = $this->webinarLiveStreamUpdateRequest($webinar_id, $webinar_live_stream);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarLiveStreamUpdateAsync
     *
     * Update a live stream
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStream $webinar_live_stream Webinar (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarLiveStreamUpdateAsync($webinar_id, $webinar_live_stream)
    {
        return $this->webinarLiveStreamUpdateAsyncWithHttpInfo($webinar_id, $webinar_live_stream)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarLiveStreamUpdateAsyncWithHttpInfo
     *
     * Update a live stream
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStream $webinar_live_stream Webinar (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarLiveStreamUpdateAsyncWithHttpInfo($webinar_id, $webinar_live_stream)
    {
        $returnType = '';
        $request = $this->webinarLiveStreamUpdateRequest($webinar_id, $webinar_live_stream);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarLiveStreamUpdate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarLiveStream $webinar_live_stream Webinar (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarLiveStreamUpdateRequest($webinar_id, $webinar_live_stream)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarLiveStreamUpdate'
            );
        }
        // verify the required parameter 'webinar_live_stream' is set
        if ($webinar_live_stream === null || (is_array($webinar_live_stream) && count($webinar_live_stream) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_live_stream when calling webinarLiveStreamUpdate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/livestream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_live_stream)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_live_stream));
            } else {
                $httpBody = $webinar_live_stream;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarLocalRecordingJoinToken
     *
     * Get a webinar&#39;s join token for local recording
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response
     */
    public function webinarLocalRecordingJoinToken($webinar_id)
    {
        list($response) = $this->webinarLocalRecordingJoinTokenWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation webinarLocalRecordingJoinTokenWithHttpInfo
     *
     * Get a webinar&#39;s join token for local recording
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarLocalRecordingJoinTokenWithHttpInfo($webinar_id)
    {
        $request = $this->webinarLocalRecordingJoinTokenRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarLocalRecordingJoinTokenAsync
     *
     * Get a webinar&#39;s join token for local recording
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarLocalRecordingJoinTokenAsync($webinar_id)
    {
        return $this->webinarLocalRecordingJoinTokenAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarLocalRecordingJoinTokenAsyncWithHttpInfo
     *
     * Get a webinar&#39;s join token for local recording
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarLocalRecordingJoinTokenAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarLocalRecordingJoinToken200Response';
        $request = $this->webinarLocalRecordingJoinTokenRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarLocalRecordingJoinToken'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarLocalRecordingJoinTokenRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarLocalRecordingJoinToken'
            );
        }

        $resourcePath = '/webinars/{webinarId}/jointoken/local_recording';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPanelistCreate
     *
     * Add panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarPanelist $webinar_panelist webinar_panelist (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarPanelistCreate($webinar_id, $webinar_panelist)
    {
        $this->webinarPanelistCreateWithHttpInfo($webinar_id, $webinar_panelist);
    }

    /**
     * Operation webinarPanelistCreateWithHttpInfo
     *
     * Add panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarPanelist $webinar_panelist (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPanelistCreateWithHttpInfo($webinar_id, $webinar_panelist)
    {
        $request = $this->webinarPanelistCreateRequest($webinar_id, $webinar_panelist);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarPanelistCreate201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPanelistCreateAsync
     *
     * Add panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarPanelist $webinar_panelist (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistCreateAsync($webinar_id, $webinar_panelist)
    {
        return $this->webinarPanelistCreateAsyncWithHttpInfo($webinar_id, $webinar_panelist)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPanelistCreateAsyncWithHttpInfo
     *
     * Add panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarPanelist $webinar_panelist (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistCreateAsyncWithHttpInfo($webinar_id, $webinar_panelist)
    {
        $returnType = '';
        $request = $this->webinarPanelistCreateRequest($webinar_id, $webinar_panelist);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPanelistCreate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarPanelist $webinar_panelist (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPanelistCreateRequest($webinar_id, $webinar_panelist)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPanelistCreate'
            );
        }
        // verify the required parameter 'webinar_panelist' is set
        if ($webinar_panelist === null || (is_array($webinar_panelist) && count($webinar_panelist) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_panelist when calling webinarPanelistCreate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/panelists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_panelist)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_panelist));
            } else {
                $httpBody = $webinar_panelist;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPanelistDelete
     *
     * Remove a panelist
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $panelist_id The panelist ID or panelist email. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarPanelistDelete($webinar_id, $panelist_id)
    {
        $this->webinarPanelistDeleteWithHttpInfo($webinar_id, $panelist_id);
    }

    /**
     * Operation webinarPanelistDeleteWithHttpInfo
     *
     * Remove a panelist
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $panelist_id The panelist ID or panelist email. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPanelistDeleteWithHttpInfo($webinar_id, $panelist_id)
    {
        $request = $this->webinarPanelistDeleteRequest($webinar_id, $panelist_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPanelistDeleteAsync
     *
     * Remove a panelist
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $panelist_id The panelist ID or panelist email. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistDeleteAsync($webinar_id, $panelist_id)
    {
        return $this->webinarPanelistDeleteAsyncWithHttpInfo($webinar_id, $panelist_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPanelistDeleteAsyncWithHttpInfo
     *
     * Remove a panelist
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $panelist_id The panelist ID or panelist email. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistDeleteAsyncWithHttpInfo($webinar_id, $panelist_id)
    {
        $returnType = '';
        $request = $this->webinarPanelistDeleteRequest($webinar_id, $panelist_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPanelistDelete'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $panelist_id The panelist ID or panelist email. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPanelistDeleteRequest($webinar_id, $panelist_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPanelistDelete'
            );
        }
        // verify the required parameter 'panelist_id' is set
        if ($panelist_id === null || (is_array($panelist_id) && count($panelist_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $panelist_id when calling webinarPanelistDelete'
            );
        }

        $resourcePath = '/webinars/{webinarId}/panelists/{panelistId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($panelist_id !== null) {
            $resourcePath = str_replace(
                '{' . 'panelistId' . '}',
                ObjectSerializer::toPathValue($panelist_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPanelists
     *
     * List panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarPanelistList
     */
    public function webinarPanelists($webinar_id)
    {
        list($response) = $this->webinarPanelistsWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation webinarPanelistsWithHttpInfo
     *
     * List panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarPanelistList, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPanelistsWithHttpInfo($webinar_id)
    {
        $request = $this->webinarPanelistsRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarPanelistList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarPanelistList' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarPanelistList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarPanelistList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarPanelistList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPanelistsAsync
     *
     * List panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistsAsync($webinar_id)
    {
        return $this->webinarPanelistsAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPanelistsAsyncWithHttpInfo
     *
     * List panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistsAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarPanelistList';
        $request = $this->webinarPanelistsRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPanelists'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPanelistsRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPanelists'
            );
        }

        $resourcePath = '/webinars/{webinarId}/panelists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPanelistsDelete
     *
     * Remove panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarPanelistsDelete($webinar_id)
    {
        $this->webinarPanelistsDeleteWithHttpInfo($webinar_id);
    }

    /**
     * Operation webinarPanelistsDeleteWithHttpInfo
     *
     * Remove panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPanelistsDeleteWithHttpInfo($webinar_id)
    {
        $request = $this->webinarPanelistsDeleteRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPanelistsDeleteAsync
     *
     * Remove panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistsDeleteAsync($webinar_id)
    {
        return $this->webinarPanelistsDeleteAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPanelistsDeleteAsyncWithHttpInfo
     *
     * Remove panelists
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPanelistsDeleteAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '';
        $request = $this->webinarPanelistsDeleteRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPanelistsDelete'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPanelistsDeleteRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPanelistsDelete'
            );
        }

        $resourcePath = '/webinars/{webinarId}/panelists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPollCreate
     *
     * Create a webinar&#39;s poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar poll object (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarPollCreate201Response
     */
    public function webinarPollCreate($webinar_id, $meeting_poll_create_request)
    {
        list($response) = $this->webinarPollCreateWithHttpInfo($webinar_id, $meeting_poll_create_request);
        return $response;
    }

    /**
     * Operation webinarPollCreateWithHttpInfo
     *
     * Create a webinar&#39;s poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar poll object (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarPollCreate201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPollCreateWithHttpInfo($webinar_id, $meeting_poll_create_request)
    {
        $request = $this->webinarPollCreateRequest($webinar_id, $meeting_poll_create_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\WebinarPollCreate201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarPollCreate201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarPollCreate201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarPollCreate201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarPollCreate201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPollCreateAsync
     *
     * Create a webinar&#39;s poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar poll object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollCreateAsync($webinar_id, $meeting_poll_create_request)
    {
        return $this->webinarPollCreateAsyncWithHttpInfo($webinar_id, $meeting_poll_create_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPollCreateAsyncWithHttpInfo
     *
     * Create a webinar&#39;s poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar poll object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollCreateAsyncWithHttpInfo($webinar_id, $meeting_poll_create_request)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarPollCreate201Response';
        $request = $this->webinarPollCreateRequest($webinar_id, $meeting_poll_create_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPollCreate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar poll object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPollCreateRequest($webinar_id, $meeting_poll_create_request)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPollCreate'
            );
        }
        // verify the required parameter 'meeting_poll_create_request' is set
        if ($meeting_poll_create_request === null || (is_array($meeting_poll_create_request) && count($meeting_poll_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meeting_poll_create_request when calling webinarPollCreate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/polls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($meeting_poll_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($meeting_poll_create_request));
            } else {
                $httpBody = $meeting_poll_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPollDelete
     *
     * Delete a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarPollDelete($webinar_id, $poll_id)
    {
        $this->webinarPollDeleteWithHttpInfo($webinar_id, $poll_id);
    }

    /**
     * Operation webinarPollDeleteWithHttpInfo
     *
     * Delete a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPollDeleteWithHttpInfo($webinar_id, $poll_id)
    {
        $request = $this->webinarPollDeleteRequest($webinar_id, $poll_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPollDeleteAsync
     *
     * Delete a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollDeleteAsync($webinar_id, $poll_id)
    {
        return $this->webinarPollDeleteAsyncWithHttpInfo($webinar_id, $poll_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPollDeleteAsyncWithHttpInfo
     *
     * Delete a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollDeleteAsyncWithHttpInfo($webinar_id, $poll_id)
    {
        $returnType = '';
        $request = $this->webinarPollDeleteRequest($webinar_id, $poll_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPollDelete'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPollDeleteRequest($webinar_id, $poll_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPollDelete'
            );
        }
        // verify the required parameter 'poll_id' is set
        if ($poll_id === null || (is_array($poll_id) && count($poll_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $poll_id when calling webinarPollDelete'
            );
        }

        $resourcePath = '/webinars/{webinarId}/polls/{pollId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($poll_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pollId' . '}',
                ObjectSerializer::toPathValue($poll_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPollGet
     *
     * Get a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarPollCreate201Response
     */
    public function webinarPollGet($webinar_id, $poll_id)
    {
        list($response) = $this->webinarPollGetWithHttpInfo($webinar_id, $poll_id);
        return $response;
    }

    /**
     * Operation webinarPollGetWithHttpInfo
     *
     * Get a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarPollCreate201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPollGetWithHttpInfo($webinar_id, $poll_id)
    {
        $request = $this->webinarPollGetRequest($webinar_id, $poll_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarPollCreate201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarPollCreate201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarPollCreate201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarPollCreate201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarPollCreate201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPollGetAsync
     *
     * Get a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollGetAsync($webinar_id, $poll_id)
    {
        return $this->webinarPollGetAsyncWithHttpInfo($webinar_id, $poll_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPollGetAsyncWithHttpInfo
     *
     * Get a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollGetAsyncWithHttpInfo($webinar_id, $poll_id)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarPollCreate201Response';
        $request = $this->webinarPollGetRequest($webinar_id, $poll_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPollGet'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPollGetRequest($webinar_id, $poll_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPollGet'
            );
        }
        // verify the required parameter 'poll_id' is set
        if ($poll_id === null || (is_array($poll_id) && count($poll_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $poll_id when calling webinarPollGet'
            );
        }

        $resourcePath = '/webinars/{webinarId}/polls/{pollId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($poll_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pollId' . '}',
                ObjectSerializer::toPathValue($poll_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPollUpdate
     *
     * Update a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar Poll (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarPollUpdate($webinar_id, $poll_id, $meeting_poll_create_request)
    {
        $this->webinarPollUpdateWithHttpInfo($webinar_id, $poll_id, $meeting_poll_create_request);
    }

    /**
     * Operation webinarPollUpdateWithHttpInfo
     *
     * Update a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar Poll (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPollUpdateWithHttpInfo($webinar_id, $poll_id, $meeting_poll_create_request)
    {
        $request = $this->webinarPollUpdateRequest($webinar_id, $poll_id, $meeting_poll_create_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPollUpdateAsync
     *
     * Update a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar Poll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollUpdateAsync($webinar_id, $poll_id, $meeting_poll_create_request)
    {
        return $this->webinarPollUpdateAsyncWithHttpInfo($webinar_id, $poll_id, $meeting_poll_create_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPollUpdateAsyncWithHttpInfo
     *
     * Update a webinar poll
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar Poll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollUpdateAsyncWithHttpInfo($webinar_id, $poll_id, $meeting_poll_create_request)
    {
        $returnType = '';
        $request = $this->webinarPollUpdateRequest($webinar_id, $poll_id, $meeting_poll_create_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPollUpdate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $poll_id The poll ID (required)
     * @param  \OpenAPI\Client\Model\MeetingPollCreateRequest $meeting_poll_create_request Webinar Poll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPollUpdateRequest($webinar_id, $poll_id, $meeting_poll_create_request)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPollUpdate'
            );
        }
        // verify the required parameter 'poll_id' is set
        if ($poll_id === null || (is_array($poll_id) && count($poll_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $poll_id when calling webinarPollUpdate'
            );
        }
        // verify the required parameter 'meeting_poll_create_request' is set
        if ($meeting_poll_create_request === null || (is_array($meeting_poll_create_request) && count($meeting_poll_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meeting_poll_create_request when calling webinarPollUpdate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/polls/{pollId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($poll_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pollId' . '}',
                ObjectSerializer::toPathValue($poll_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($meeting_poll_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($meeting_poll_create_request));
            } else {
                $httpBody = $meeting_poll_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarPolls
     *
     * List a webinar&#39;s polls
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  bool $anonymous Whether to query for polls with the **Anonymous** option enabled:  * &#x60;true&#x60;  Query for polls with the **Anonymous** option enabled.  * &#x60;false&#x60;  Do not query for polls with the **Anonymous** option enabled. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PollList
     */
    public function webinarPolls($webinar_id, $anonymous = null)
    {
        list($response) = $this->webinarPollsWithHttpInfo($webinar_id, $anonymous);
        return $response;
    }

    /**
     * Operation webinarPollsWithHttpInfo
     *
     * List a webinar&#39;s polls
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  bool $anonymous Whether to query for polls with the **Anonymous** option enabled:  * &#x60;true&#x60;  Query for polls with the **Anonymous** option enabled.  * &#x60;false&#x60;  Do not query for polls with the **Anonymous** option enabled. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PollList, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarPollsWithHttpInfo($webinar_id, $anonymous = null)
    {
        $request = $this->webinarPollsRequest($webinar_id, $anonymous);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PollList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PollList' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PollList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PollList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PollList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarPollsAsync
     *
     * List a webinar&#39;s polls
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  bool $anonymous Whether to query for polls with the **Anonymous** option enabled:  * &#x60;true&#x60;  Query for polls with the **Anonymous** option enabled.  * &#x60;false&#x60;  Do not query for polls with the **Anonymous** option enabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollsAsync($webinar_id, $anonymous = null)
    {
        return $this->webinarPollsAsyncWithHttpInfo($webinar_id, $anonymous)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarPollsAsyncWithHttpInfo
     *
     * List a webinar&#39;s polls
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  bool $anonymous Whether to query for polls with the **Anonymous** option enabled:  * &#x60;true&#x60;  Query for polls with the **Anonymous** option enabled.  * &#x60;false&#x60;  Do not query for polls with the **Anonymous** option enabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarPollsAsyncWithHttpInfo($webinar_id, $anonymous = null)
    {
        $returnType = '\OpenAPI\Client\Model\PollList';
        $request = $this->webinarPollsRequest($webinar_id, $anonymous);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarPolls'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  bool $anonymous Whether to query for polls with the **Anonymous** option enabled:  * &#x60;true&#x60;  Query for polls with the **Anonymous** option enabled.  * &#x60;false&#x60;  Do not query for polls with the **Anonymous** option enabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarPollsRequest($webinar_id, $anonymous = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarPolls'
            );
        }

        $resourcePath = '/webinars/{webinarId}/polls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anonymous,
            'anonymous', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarRegistrantCreate
     *
     * Add a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantCreateRequest $webinar_registrant_create_request webinar_registrant_create_request (required)
     * @param  string $occurrence_ids A comma-separated list of webinar occurrence IDs. You can get this value with the [Get a webinar](/docs/api-reference/zoom-api/methods/#operation/webinarUpdate) API. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarRegistrantCreate201Response
     */
    public function webinarRegistrantCreate($webinar_id, $webinar_registrant_create_request, $occurrence_ids = null)
    {
        list($response) = $this->webinarRegistrantCreateWithHttpInfo($webinar_id, $webinar_registrant_create_request, $occurrence_ids);
        return $response;
    }

    /**
     * Operation webinarRegistrantCreateWithHttpInfo
     *
     * Add a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantCreateRequest $webinar_registrant_create_request (required)
     * @param  string $occurrence_ids A comma-separated list of webinar occurrence IDs. You can get this value with the [Get a webinar](/docs/api-reference/zoom-api/methods/#operation/webinarUpdate) API. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarRegistrantCreate201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarRegistrantCreateWithHttpInfo($webinar_id, $webinar_registrant_create_request, $occurrence_ids = null)
    {
        $request = $this->webinarRegistrantCreateRequest($webinar_id, $webinar_registrant_create_request, $occurrence_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\WebinarRegistrantCreate201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarRegistrantCreate201Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarRegistrantCreate201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarRegistrantCreate201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarRegistrantCreate201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarRegistrantCreateAsync
     *
     * Add a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantCreateRequest $webinar_registrant_create_request (required)
     * @param  string $occurrence_ids A comma-separated list of webinar occurrence IDs. You can get this value with the [Get a webinar](/docs/api-reference/zoom-api/methods/#operation/webinarUpdate) API. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantCreateAsync($webinar_id, $webinar_registrant_create_request, $occurrence_ids = null)
    {
        return $this->webinarRegistrantCreateAsyncWithHttpInfo($webinar_id, $webinar_registrant_create_request, $occurrence_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarRegistrantCreateAsyncWithHttpInfo
     *
     * Add a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantCreateRequest $webinar_registrant_create_request (required)
     * @param  string $occurrence_ids A comma-separated list of webinar occurrence IDs. You can get this value with the [Get a webinar](/docs/api-reference/zoom-api/methods/#operation/webinarUpdate) API. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantCreateAsyncWithHttpInfo($webinar_id, $webinar_registrant_create_request, $occurrence_ids = null)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarRegistrantCreate201Response';
        $request = $this->webinarRegistrantCreateRequest($webinar_id, $webinar_registrant_create_request, $occurrence_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarRegistrantCreate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantCreateRequest $webinar_registrant_create_request (required)
     * @param  string $occurrence_ids A comma-separated list of webinar occurrence IDs. You can get this value with the [Get a webinar](/docs/api-reference/zoom-api/methods/#operation/webinarUpdate) API. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarRegistrantCreateRequest($webinar_id, $webinar_registrant_create_request, $occurrence_ids = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarRegistrantCreate'
            );
        }
        // verify the required parameter 'webinar_registrant_create_request' is set
        if ($webinar_registrant_create_request === null || (is_array($webinar_registrant_create_request) && count($webinar_registrant_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_registrant_create_request when calling webinarRegistrantCreate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/registrants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_ids,
            'occurrence_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_registrant_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_registrant_create_request));
            } else {
                $httpBody = $webinar_registrant_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarRegistrantGet
     *
     * Get a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarRegistrant
     */
    public function webinarRegistrantGet($webinar_id, $registrant_id, $occurrence_id = null)
    {
        list($response) = $this->webinarRegistrantGetWithHttpInfo($webinar_id, $registrant_id, $occurrence_id);
        return $response;
    }

    /**
     * Operation webinarRegistrantGetWithHttpInfo
     *
     * Get a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarRegistrantGetWithHttpInfo($webinar_id, $registrant_id, $occurrence_id = null)
    {
        $request = $this->webinarRegistrantGetRequest($webinar_id, $registrant_id, $occurrence_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarRegistrant' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarRegistrantGetAsync
     *
     * Get a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantGetAsync($webinar_id, $registrant_id, $occurrence_id = null)
    {
        return $this->webinarRegistrantGetAsyncWithHttpInfo($webinar_id, $registrant_id, $occurrence_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarRegistrantGetAsyncWithHttpInfo
     *
     * Get a webinar registrant
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantGetAsyncWithHttpInfo($webinar_id, $registrant_id, $occurrence_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarRegistrant';
        $request = $this->webinarRegistrantGetRequest($webinar_id, $registrant_id, $occurrence_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarRegistrantGet'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $registrant_id The registrant ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarRegistrantGetRequest($webinar_id, $registrant_id, $occurrence_id = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarRegistrantGet'
            );
        }
        // verify the required parameter 'registrant_id' is set
        if ($registrant_id === null || (is_array($registrant_id) && count($registrant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registrant_id when calling webinarRegistrantGet'
            );
        }

        $resourcePath = '/webinars/{webinarId}/registrants/{registrantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }
        // path params
        if ($registrant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrantId' . '}',
                ObjectSerializer::toPathValue($registrant_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarRegistrantQuestionUpdate
     *
     * Update registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response $webinar_registrants_questions_get200_response Webinar Registrant Questions (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarRegistrantQuestionUpdate($webinar_id, $webinar_registrants_questions_get200_response)
    {
        $this->webinarRegistrantQuestionUpdateWithHttpInfo($webinar_id, $webinar_registrants_questions_get200_response);
    }

    /**
     * Operation webinarRegistrantQuestionUpdateWithHttpInfo
     *
     * Update registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response $webinar_registrants_questions_get200_response Webinar Registrant Questions (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarRegistrantQuestionUpdateWithHttpInfo($webinar_id, $webinar_registrants_questions_get200_response)
    {
        $request = $this->webinarRegistrantQuestionUpdateRequest($webinar_id, $webinar_registrants_questions_get200_response);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarRegistrantQuestionUpdateAsync
     *
     * Update registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response $webinar_registrants_questions_get200_response Webinar Registrant Questions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantQuestionUpdateAsync($webinar_id, $webinar_registrants_questions_get200_response)
    {
        return $this->webinarRegistrantQuestionUpdateAsyncWithHttpInfo($webinar_id, $webinar_registrants_questions_get200_response)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarRegistrantQuestionUpdateAsyncWithHttpInfo
     *
     * Update registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response $webinar_registrants_questions_get200_response Webinar Registrant Questions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantQuestionUpdateAsyncWithHttpInfo($webinar_id, $webinar_registrants_questions_get200_response)
    {
        $returnType = '';
        $request = $this->webinarRegistrantQuestionUpdateRequest($webinar_id, $webinar_registrants_questions_get200_response);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarRegistrantQuestionUpdate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response $webinar_registrants_questions_get200_response Webinar Registrant Questions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarRegistrantQuestionUpdateRequest($webinar_id, $webinar_registrants_questions_get200_response)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarRegistrantQuestionUpdate'
            );
        }
        // verify the required parameter 'webinar_registrants_questions_get200_response' is set
        if ($webinar_registrants_questions_get200_response === null || (is_array($webinar_registrants_questions_get200_response) && count($webinar_registrants_questions_get200_response) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_registrants_questions_get200_response when calling webinarRegistrantQuestionUpdate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/registrants/questions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_registrants_questions_get200_response)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_registrants_questions_get200_response));
            } else {
                $httpBody = $webinar_registrants_questions_get200_response;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarRegistrantStatus
     *
     * Update registrant&#39;s status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantStatusRequest $webinar_registrant_status_request webinar_registrant_status_request (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarRegistrantStatus($webinar_id, $webinar_registrant_status_request, $occurrence_id = null)
    {
        $this->webinarRegistrantStatusWithHttpInfo($webinar_id, $webinar_registrant_status_request, $occurrence_id);
    }

    /**
     * Operation webinarRegistrantStatusWithHttpInfo
     *
     * Update registrant&#39;s status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantStatusRequest $webinar_registrant_status_request (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarRegistrantStatusWithHttpInfo($webinar_id, $webinar_registrant_status_request, $occurrence_id = null)
    {
        $request = $this->webinarRegistrantStatusRequest($webinar_id, $webinar_registrant_status_request, $occurrence_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarRegistrantStatusAsync
     *
     * Update registrant&#39;s status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantStatusRequest $webinar_registrant_status_request (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantStatusAsync($webinar_id, $webinar_registrant_status_request, $occurrence_id = null)
    {
        return $this->webinarRegistrantStatusAsyncWithHttpInfo($webinar_id, $webinar_registrant_status_request, $occurrence_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarRegistrantStatusAsyncWithHttpInfo
     *
     * Update registrant&#39;s status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantStatusRequest $webinar_registrant_status_request (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantStatusAsyncWithHttpInfo($webinar_id, $webinar_registrant_status_request, $occurrence_id = null)
    {
        $returnType = '';
        $request = $this->webinarRegistrantStatusRequest($webinar_id, $webinar_registrant_status_request, $occurrence_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarRegistrantStatus'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarRegistrantStatusRequest $webinar_registrant_status_request (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarRegistrantStatusRequest($webinar_id, $webinar_registrant_status_request, $occurrence_id = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarRegistrantStatus'
            );
        }
        // verify the required parameter 'webinar_registrant_status_request' is set
        if ($webinar_registrant_status_request === null || (is_array($webinar_registrant_status_request) && count($webinar_registrant_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_registrant_status_request when calling webinarRegistrantStatus'
            );
        }

        $resourcePath = '/webinars/{webinarId}/registrants/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_registrant_status_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_registrant_status_request));
            } else {
                $httpBody = $webinar_registrant_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarRegistrants
     *
     * List webinar registrants
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  string $status Query by the registrant&#39;s status:  * &#x60;pending&#x60;  The registration is pending.  * &#x60;approved&#x60;  The registrant is approved.  * &#x60;denied&#x60;  The registration is denied. (optional, default to 'approved')
     * @param  string $tracking_source_id The tracking source ID for the registrants. Useful if you share the webinar registration page in multiple locations. See [Creating source tracking links for webinar registration](https://support.zoom.us/hc/en-us/articles/360000315683-Creating-source-tracking-links-for-webinar-registration) for details. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarRegistrantList
     */
    public function webinarRegistrants($webinar_id, $occurrence_id = null, $status = 'approved', $tracking_source_id = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        list($response) = $this->webinarRegistrantsWithHttpInfo($webinar_id, $occurrence_id, $status, $tracking_source_id, $page_size, $page_number, $next_page_token);
        return $response;
    }

    /**
     * Operation webinarRegistrantsWithHttpInfo
     *
     * List webinar registrants
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  string $status Query by the registrant&#39;s status:  * &#x60;pending&#x60;  The registration is pending.  * &#x60;approved&#x60;  The registrant is approved.  * &#x60;denied&#x60;  The registration is denied. (optional, default to 'approved')
     * @param  string $tracking_source_id The tracking source ID for the registrants. Useful if you share the webinar registration page in multiple locations. See [Creating source tracking links for webinar registration](https://support.zoom.us/hc/en-us/articles/360000315683-Creating-source-tracking-links-for-webinar-registration) for details. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarRegistrantList, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarRegistrantsWithHttpInfo($webinar_id, $occurrence_id = null, $status = 'approved', $tracking_source_id = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        $request = $this->webinarRegistrantsRequest($webinar_id, $occurrence_id, $status, $tracking_source_id, $page_size, $page_number, $next_page_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarRegistrantList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarRegistrantList' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarRegistrantList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarRegistrantList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarRegistrantList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarRegistrantsAsync
     *
     * List webinar registrants
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  string $status Query by the registrant&#39;s status:  * &#x60;pending&#x60;  The registration is pending.  * &#x60;approved&#x60;  The registrant is approved.  * &#x60;denied&#x60;  The registration is denied. (optional, default to 'approved')
     * @param  string $tracking_source_id The tracking source ID for the registrants. Useful if you share the webinar registration page in multiple locations. See [Creating source tracking links for webinar registration](https://support.zoom.us/hc/en-us/articles/360000315683-Creating-source-tracking-links-for-webinar-registration) for details. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantsAsync($webinar_id, $occurrence_id = null, $status = 'approved', $tracking_source_id = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        return $this->webinarRegistrantsAsyncWithHttpInfo($webinar_id, $occurrence_id, $status, $tracking_source_id, $page_size, $page_number, $next_page_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarRegistrantsAsyncWithHttpInfo
     *
     * List webinar registrants
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  string $status Query by the registrant&#39;s status:  * &#x60;pending&#x60;  The registration is pending.  * &#x60;approved&#x60;  The registrant is approved.  * &#x60;denied&#x60;  The registration is denied. (optional, default to 'approved')
     * @param  string $tracking_source_id The tracking source ID for the registrants. Useful if you share the webinar registration page in multiple locations. See [Creating source tracking links for webinar registration](https://support.zoom.us/hc/en-us/articles/360000315683-Creating-source-tracking-links-for-webinar-registration) for details. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantsAsyncWithHttpInfo($webinar_id, $occurrence_id = null, $status = 'approved', $tracking_source_id = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarRegistrantList';
        $request = $this->webinarRegistrantsRequest($webinar_id, $occurrence_id, $status, $tracking_source_id, $page_size, $page_number, $next_page_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarRegistrants'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $occurrence_id The meeting or webinar occurrence ID. (optional)
     * @param  string $status Query by the registrant&#39;s status:  * &#x60;pending&#x60;  The registration is pending.  * &#x60;approved&#x60;  The registrant is approved.  * &#x60;denied&#x60;  The registration is denied. (optional, default to 'approved')
     * @param  string $tracking_source_id The tracking source ID for the registrants. Useful if you share the webinar registration page in multiple locations. See [Creating source tracking links for webinar registration](https://support.zoom.us/hc/en-us/articles/360000315683-Creating-source-tracking-links-for-webinar-registration) for details. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarRegistrantsRequest($webinar_id, $occurrence_id = null, $status = 'approved', $tracking_source_id = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarRegistrants'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling WebinarsApi.webinarRegistrants, must be smaller than or equal to 300.');
        }


        $resourcePath = '/webinars/{webinarId}/registrants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tracking_source_id,
            'tracking_source_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_number,
            'page_number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarRegistrantsQuestionsGet
     *
     * List registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response
     */
    public function webinarRegistrantsQuestionsGet($webinar_id)
    {
        list($response) = $this->webinarRegistrantsQuestionsGetWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation webinarRegistrantsQuestionsGetWithHttpInfo
     *
     * List registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarRegistrantsQuestionsGetWithHttpInfo($webinar_id)
    {
        $request = $this->webinarRegistrantsQuestionsGetRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarRegistrantsQuestionsGetAsync
     *
     * List registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantsQuestionsGetAsync($webinar_id)
    {
        return $this->webinarRegistrantsQuestionsGetAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarRegistrantsQuestionsGetAsyncWithHttpInfo
     *
     * List registration questions
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarRegistrantsQuestionsGetAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarRegistrantsQuestionsGet200Response';
        $request = $this->webinarRegistrantsQuestionsGetRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarRegistrantsQuestionsGet'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarRegistrantsQuestionsGetRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarRegistrantsQuestionsGet'
            );
        }

        $resourcePath = '/webinars/{webinarId}/registrants/questions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarStatus
     *
     * Update webinar status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarStatusRequest $webinar_status_request webinar_status_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarStatus($webinar_id, $webinar_status_request)
    {
        $this->webinarStatusWithHttpInfo($webinar_id, $webinar_status_request);
    }

    /**
     * Operation webinarStatusWithHttpInfo
     *
     * Update webinar status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarStatusRequest $webinar_status_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarStatusWithHttpInfo($webinar_id, $webinar_status_request)
    {
        $request = $this->webinarStatusRequest($webinar_id, $webinar_status_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarStatusAsync
     *
     * Update webinar status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarStatusRequest $webinar_status_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarStatusAsync($webinar_id, $webinar_status_request)
    {
        return $this->webinarStatusAsyncWithHttpInfo($webinar_id, $webinar_status_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarStatusAsyncWithHttpInfo
     *
     * Update webinar status
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarStatusRequest $webinar_status_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarStatusAsyncWithHttpInfo($webinar_id, $webinar_status_request)
    {
        $returnType = '';
        $request = $this->webinarStatusRequest($webinar_id, $webinar_status_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarStatus'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarStatusRequest $webinar_status_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarStatusRequest($webinar_id, $webinar_status_request)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarStatus'
            );
        }
        // verify the required parameter 'webinar_status_request' is set
        if ($webinar_status_request === null || (is_array($webinar_status_request) && count($webinar_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_status_request when calling webinarStatus'
            );
        }

        $resourcePath = '/webinars/{webinarId}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_status_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_status_request));
            } else {
                $httpBody = $webinar_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarSurveyDelete
     *
     * Delete a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarSurveyDelete($webinar_id)
    {
        $this->webinarSurveyDeleteWithHttpInfo($webinar_id);
    }

    /**
     * Operation webinarSurveyDeleteWithHttpInfo
     *
     * Delete a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarSurveyDeleteWithHttpInfo($webinar_id)
    {
        $request = $this->webinarSurveyDeleteRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarSurveyDeleteAsync
     *
     * Delete a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarSurveyDeleteAsync($webinar_id)
    {
        return $this->webinarSurveyDeleteAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarSurveyDeleteAsyncWithHttpInfo
     *
     * Delete a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarSurveyDeleteAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '';
        $request = $this->webinarSurveyDeleteRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarSurveyDelete'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarSurveyDeleteRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarSurveyDelete'
            );
        }

        $resourcePath = '/webinars/{webinarId}/survey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarSurveyGet
     *
     * Get a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarSurveyGet200Response
     */
    public function webinarSurveyGet($webinar_id)
    {
        list($response) = $this->webinarSurveyGetWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation webinarSurveyGetWithHttpInfo
     *
     * Get a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarSurveyGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarSurveyGetWithHttpInfo($webinar_id)
    {
        $request = $this->webinarSurveyGetRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarSurveyGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarSurveyGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarSurveyGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarSurveyGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarSurveyGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarSurveyGetAsync
     *
     * Get a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarSurveyGetAsync($webinar_id)
    {
        return $this->webinarSurveyGetAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarSurveyGetAsyncWithHttpInfo
     *
     * Get a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarSurveyGetAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarSurveyGet200Response';
        $request = $this->webinarSurveyGetRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarSurveyGet'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarSurveyGetRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarSurveyGet'
            );
        }

        $resourcePath = '/webinars/{webinarId}/survey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarSurveyUpdate
     *
     * Update a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarSurveyGet200Response $webinar_survey_get200_response webinar_survey_get200_response (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarSurveyUpdate($webinar_id, $webinar_survey_get200_response)
    {
        $this->webinarSurveyUpdateWithHttpInfo($webinar_id, $webinar_survey_get200_response);
    }

    /**
     * Operation webinarSurveyUpdateWithHttpInfo
     *
     * Update a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarSurveyGet200Response $webinar_survey_get200_response (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarSurveyUpdateWithHttpInfo($webinar_id, $webinar_survey_get200_response)
    {
        $request = $this->webinarSurveyUpdateRequest($webinar_id, $webinar_survey_get200_response);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarSurveyUpdateAsync
     *
     * Update a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarSurveyGet200Response $webinar_survey_get200_response (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarSurveyUpdateAsync($webinar_id, $webinar_survey_get200_response)
    {
        return $this->webinarSurveyUpdateAsyncWithHttpInfo($webinar_id, $webinar_survey_get200_response)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarSurveyUpdateAsyncWithHttpInfo
     *
     * Update a webinar survey
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarSurveyGet200Response $webinar_survey_get200_response (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarSurveyUpdateAsyncWithHttpInfo($webinar_id, $webinar_survey_get200_response)
    {
        $returnType = '';
        $request = $this->webinarSurveyUpdateRequest($webinar_id, $webinar_survey_get200_response);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarSurveyUpdate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarSurveyGet200Response $webinar_survey_get200_response (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarSurveyUpdateRequest($webinar_id, $webinar_survey_get200_response)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarSurveyUpdate'
            );
        }
        // verify the required parameter 'webinar_survey_get200_response' is set
        if ($webinar_survey_get200_response === null || (is_array($webinar_survey_get200_response) && count($webinar_survey_get200_response) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_survey_get200_response when calling webinarSurveyUpdate'
            );
        }

        $resourcePath = '/webinars/{webinarId}/survey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_survey_get200_response)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_survey_get200_response));
            } else {
                $httpBody = $webinar_survey_get200_response;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarToken
     *
     * Get webinar&#39;s token
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $type The webinar token type:  * &#x60;closed_caption_token&#x60;  The third-party closed caption API token.   This defaults to &#x60;closed_caption_token&#x60;. (optional, default to 'closed_caption_token')
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarToken200Response
     */
    public function webinarToken($webinar_id, $type = 'closed_caption_token')
    {
        list($response) = $this->webinarTokenWithHttpInfo($webinar_id, $type);
        return $response;
    }

    /**
     * Operation webinarTokenWithHttpInfo
     *
     * Get webinar&#39;s token
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $type The webinar token type:  * &#x60;closed_caption_token&#x60;  The third-party closed caption API token.   This defaults to &#x60;closed_caption_token&#x60;. (optional, default to 'closed_caption_token')
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarToken200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarTokenWithHttpInfo($webinar_id, $type = 'closed_caption_token')
    {
        $request = $this->webinarTokenRequest($webinar_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarToken200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarToken200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarToken200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarToken200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarToken200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarTokenAsync
     *
     * Get webinar&#39;s token
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $type The webinar token type:  * &#x60;closed_caption_token&#x60;  The third-party closed caption API token.   This defaults to &#x60;closed_caption_token&#x60;. (optional, default to 'closed_caption_token')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarTokenAsync($webinar_id, $type = 'closed_caption_token')
    {
        return $this->webinarTokenAsyncWithHttpInfo($webinar_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarTokenAsyncWithHttpInfo
     *
     * Get webinar&#39;s token
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $type The webinar token type:  * &#x60;closed_caption_token&#x60;  The third-party closed caption API token.   This defaults to &#x60;closed_caption_token&#x60;. (optional, default to 'closed_caption_token')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarTokenAsyncWithHttpInfo($webinar_id, $type = 'closed_caption_token')
    {
        $returnType = '\OpenAPI\Client\Model\WebinarToken200Response';
        $request = $this->webinarTokenRequest($webinar_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarToken'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  string $type The webinar token type:  * &#x60;closed_caption_token&#x60;  The third-party closed caption API token.   This defaults to &#x60;closed_caption_token&#x60;. (optional, default to 'closed_caption_token')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarTokenRequest($webinar_id, $type = 'closed_caption_token')
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarToken'
            );
        }

        $resourcePath = '/webinars/{webinarId}/token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinarUpdate
     *
     * Update a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarUpdate $webinar_update Webinar. (required)
     * @param  string $occurrence_id Webinar occurrence id. Support change of agenda, start_time, duration, settings: {host_video, panelist_video, hd_video, watermark, auto_recording} (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function webinarUpdate($webinar_id, $webinar_update, $occurrence_id = null)
    {
        $this->webinarUpdateWithHttpInfo($webinar_id, $webinar_update, $occurrence_id);
    }

    /**
     * Operation webinarUpdateWithHttpInfo
     *
     * Update a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarUpdate $webinar_update Webinar. (required)
     * @param  string $occurrence_id Webinar occurrence id. Support change of agenda, start_time, duration, settings: {host_video, panelist_video, hd_video, watermark, auto_recording} (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarUpdateWithHttpInfo($webinar_id, $webinar_update, $occurrence_id = null)
    {
        $request = $this->webinarUpdateRequest($webinar_id, $webinar_update, $occurrence_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation webinarUpdateAsync
     *
     * Update a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarUpdate $webinar_update Webinar. (required)
     * @param  string $occurrence_id Webinar occurrence id. Support change of agenda, start_time, duration, settings: {host_video, panelist_video, hd_video, watermark, auto_recording} (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarUpdateAsync($webinar_id, $webinar_update, $occurrence_id = null)
    {
        return $this->webinarUpdateAsyncWithHttpInfo($webinar_id, $webinar_update, $occurrence_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarUpdateAsyncWithHttpInfo
     *
     * Update a webinar
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarUpdate $webinar_update Webinar. (required)
     * @param  string $occurrence_id Webinar occurrence id. Support change of agenda, start_time, duration, settings: {host_video, panelist_video, hd_video, watermark, auto_recording} (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarUpdateAsyncWithHttpInfo($webinar_id, $webinar_update, $occurrence_id = null)
    {
        $returnType = '';
        $request = $this->webinarUpdateRequest($webinar_id, $webinar_update, $occurrence_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinarUpdate'
     *
     * @param  int $webinar_id The webinar&#39;s ID. (required)
     * @param  \OpenAPI\Client\Model\WebinarUpdate $webinar_update Webinar. (required)
     * @param  string $occurrence_id Webinar occurrence id. Support change of agenda, start_time, duration, settings: {host_video, panelist_video, hd_video, watermark, auto_recording} (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarUpdateRequest($webinar_id, $webinar_update, $occurrence_id = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling webinarUpdate'
            );
        }
        // verify the required parameter 'webinar_update' is set
        if ($webinar_update === null || (is_array($webinar_update) && count($webinar_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_update when calling webinarUpdate'
            );
        }

        $resourcePath = '/webinars/{webinarId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occurrence_id,
            'occurrence_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($webinar_update)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webinar_update));
            } else {
                $httpBody = $webinar_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webinars
     *
     * List webinars
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WebinarList
     */
    public function webinars($user_id, $page_size = 30, $page_number = 1)
    {
        list($response) = $this->webinarsWithHttpInfo($user_id, $page_size, $page_number);
        return $response;
    }

    /**
     * Operation webinarsWithHttpInfo
     *
     * List webinars
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WebinarList, HTTP status code, HTTP response headers (array of strings)
     */
    public function webinarsWithHttpInfo($user_id, $page_size = 30, $page_number = 1)
    {
        $request = $this->webinarsRequest($user_id, $page_size, $page_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WebinarList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WebinarList' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WebinarList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WebinarList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WebinarList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webinarsAsync
     *
     * List webinars
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarsAsync($user_id, $page_size = 30, $page_number = 1)
    {
        return $this->webinarsAsyncWithHttpInfo($user_id, $page_size, $page_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webinarsAsyncWithHttpInfo
     *
     * List webinars
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webinarsAsyncWithHttpInfo($user_id, $page_size = 30, $page_number = 1)
    {
        $returnType = '\OpenAPI\Client\Model\WebinarList';
        $request = $this->webinarsRequest($user_id, $page_size, $page_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webinars'
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number **Deprecated.** We will no longer support this field in a future release. Instead, use the &#x60;next_page_token&#x60; for pagination. (optional, default to 1) (deprecated)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function webinarsRequest($user_id, $page_size = 30, $page_number = 1)
    {
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling webinars'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling WebinarsApi.webinars, must be smaller than or equal to 300.');
        }


        $resourcePath = '/users/{userId}/webinars';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_number,
            'page_number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
