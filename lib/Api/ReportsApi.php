<?php
/**
 * ReportsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Zoom\Api
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Zoom Meeting API
 *
 * The Zoom Meeting APIs let developers to access information from Zoom. You can use this API to build private services or public applications on the [Zoom App Marketplace](http://marketplace.zoom.us). To learn how to get your credentials and create private/public applications, read our [JWT](/guides/auth/jwt) and [OAuth](/guides/auth/oauth) documentation.   All endpoints are available via `https` and are located at `api.zoom.us/v2/`. For example, to list all of an account's users, use the `https://api.zoom.us/v2/users/` endpoint.
 *
 * The version of the OpenAPI document: 2.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Zoom\Api\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zoom\Api\ApiException;
use Zoom\Api\Configuration;
use Zoom\Api\HeaderSelector;
use Zoom\Api\ObjectSerializer;

/**
 * ReportsApi Class Doc Comment
 *
 * @category Class
 * @package  Zoom\Api
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ReportsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getBillingInvoicesReports
     *
     * Get billing invoice reports
     *
     * @param  string $billing_id Unique Identifier of the Billing Report. Retrieve this ID from the response of **Get Billing Reports** API request. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\GetBillingInvoicesReports200Response
     */
    public function getBillingInvoicesReports($billing_id = null)
    {
        list($response) = $this->getBillingInvoicesReportsWithHttpInfo($billing_id);
        return $response;
    }

    /**
     * Operation getBillingInvoicesReportsWithHttpInfo
     *
     * Get billing invoice reports
     *
     * @param  string $billing_id Unique Identifier of the Billing Report. Retrieve this ID from the response of **Get Billing Reports** API request. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\GetBillingInvoicesReports200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillingInvoicesReportsWithHttpInfo($billing_id = null)
    {
        $request = $this->getBillingInvoicesReportsRequest($billing_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\GetBillingInvoicesReports200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\GetBillingInvoicesReports200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\GetBillingInvoicesReports200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\GetBillingInvoicesReports200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\GetBillingInvoicesReports200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillingInvoicesReportsAsync
     *
     * Get billing invoice reports
     *
     * @param  string $billing_id Unique Identifier of the Billing Report. Retrieve this ID from the response of **Get Billing Reports** API request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingInvoicesReportsAsync($billing_id = null)
    {
        return $this->getBillingInvoicesReportsAsyncWithHttpInfo($billing_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillingInvoicesReportsAsyncWithHttpInfo
     *
     * Get billing invoice reports
     *
     * @param  string $billing_id Unique Identifier of the Billing Report. Retrieve this ID from the response of **Get Billing Reports** API request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingInvoicesReportsAsyncWithHttpInfo($billing_id = null)
    {
        $returnType = '\Zoom\Api\Model\GetBillingInvoicesReports200Response';
        $request = $this->getBillingInvoicesReportsRequest($billing_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillingInvoicesReports'
     *
     * @param  string $billing_id Unique Identifier of the Billing Report. Retrieve this ID from the response of **Get Billing Reports** API request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBillingInvoicesReportsRequest($billing_id = null)
    {

        $resourcePath = '/report/billing/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_id,
            'billing_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBillingReport
     *
     * Get billing reports
     *
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\GetBillingReport200Response
     */
    public function getBillingReport()
    {
        list($response) = $this->getBillingReportWithHttpInfo();
        return $response;
    }

    /**
     * Operation getBillingReportWithHttpInfo
     *
     * Get billing reports
     *
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\GetBillingReport200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillingReportWithHttpInfo()
    {
        $request = $this->getBillingReportRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\GetBillingReport200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\GetBillingReport200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\GetBillingReport200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\GetBillingReport200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\GetBillingReport200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillingReportAsync
     *
     * Get billing reports
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingReportAsync()
    {
        return $this->getBillingReportAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillingReportAsyncWithHttpInfo
     *
     * Get billing reports
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingReportAsyncWithHttpInfo()
    {
        $returnType = '\Zoom\Api\Model\GetBillingReport200Response';
        $request = $this->getBillingReportRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillingReport'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBillingReportRequest()
    {

        $resourcePath = '/report/billing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportChatMessages
     *
     * Get chat messages reports
     *
     * @param  string $session_id Chat session ID. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $include_fields Return all edited and deleted messages. The API only returns this value if the &#x60;include_fields&#x60; query parameter contains the &#x60;edited_messages&#x60; and/or the &#x60;deleted_messages&#x60; values.  To include both edited and deleted messages, comma-separate both values. (optional)
     * @param  bool $include_bot_message Whether to return the bot message. If false, the bot_message will not be returned in the response body. (optional, default to false)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportChatMessages200Response
     */
    public function reportChatMessages($session_id, $from, $to, $next_page_token = null, $page_size = 30, $include_fields = null, $include_bot_message = false)
    {
        list($response) = $this->reportChatMessagesWithHttpInfo($session_id, $from, $to, $next_page_token, $page_size, $include_fields, $include_bot_message);
        return $response;
    }

    /**
     * Operation reportChatMessagesWithHttpInfo
     *
     * Get chat messages reports
     *
     * @param  string $session_id Chat session ID. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $include_fields Return all edited and deleted messages. The API only returns this value if the &#x60;include_fields&#x60; query parameter contains the &#x60;edited_messages&#x60; and/or the &#x60;deleted_messages&#x60; values.  To include both edited and deleted messages, comma-separate both values. (optional)
     * @param  bool $include_bot_message Whether to return the bot message. If false, the bot_message will not be returned in the response body. (optional, default to false)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportChatMessages200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportChatMessagesWithHttpInfo($session_id, $from, $to, $next_page_token = null, $page_size = 30, $include_fields = null, $include_bot_message = false)
    {
        $request = $this->reportChatMessagesRequest($session_id, $from, $to, $next_page_token, $page_size, $include_fields, $include_bot_message);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportChatMessages200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportChatMessages200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportChatMessages200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportChatMessages200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportChatMessages200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportChatMessagesAsync
     *
     * Get chat messages reports
     *
     * @param  string $session_id Chat session ID. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $include_fields Return all edited and deleted messages. The API only returns this value if the &#x60;include_fields&#x60; query parameter contains the &#x60;edited_messages&#x60; and/or the &#x60;deleted_messages&#x60; values.  To include both edited and deleted messages, comma-separate both values. (optional)
     * @param  bool $include_bot_message Whether to return the bot message. If false, the bot_message will not be returned in the response body. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportChatMessagesAsync($session_id, $from, $to, $next_page_token = null, $page_size = 30, $include_fields = null, $include_bot_message = false)
    {
        return $this->reportChatMessagesAsyncWithHttpInfo($session_id, $from, $to, $next_page_token, $page_size, $include_fields, $include_bot_message)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportChatMessagesAsyncWithHttpInfo
     *
     * Get chat messages reports
     *
     * @param  string $session_id Chat session ID. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $include_fields Return all edited and deleted messages. The API only returns this value if the &#x60;include_fields&#x60; query parameter contains the &#x60;edited_messages&#x60; and/or the &#x60;deleted_messages&#x60; values.  To include both edited and deleted messages, comma-separate both values. (optional)
     * @param  bool $include_bot_message Whether to return the bot message. If false, the bot_message will not be returned in the response body. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportChatMessagesAsyncWithHttpInfo($session_id, $from, $to, $next_page_token = null, $page_size = 30, $include_fields = null, $include_bot_message = false)
    {
        $returnType = '\Zoom\Api\Model\ReportChatMessages200Response';
        $request = $this->reportChatMessagesRequest($session_id, $from, $to, $next_page_token, $page_size, $include_fields, $include_bot_message);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportChatMessages'
     *
     * @param  string $session_id Chat session ID. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $include_fields Return all edited and deleted messages. The API only returns this value if the &#x60;include_fields&#x60; query parameter contains the &#x60;edited_messages&#x60; and/or the &#x60;deleted_messages&#x60; values.  To include both edited and deleted messages, comma-separate both values. (optional)
     * @param  bool $include_bot_message Whether to return the bot message. If false, the bot_message will not be returned in the response body. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportChatMessagesRequest($session_id, $from, $to, $next_page_token = null, $page_size = 30, $include_fields = null, $include_bot_message = false)
    {
        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling reportChatMessages'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportChatMessages'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportChatMessages'
            );
        }
        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportChatMessages, must be smaller than or equal to 100.');
        }


        $resourcePath = '/report/chat/sessions/{sessionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_fields,
            'include_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_bot_message,
            'include_bot_message', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'sessionId' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportChatSessions
     *
     * Get chat sessions reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportChatSessions200Response
     */
    public function reportChatSessions($from, $to, $page_size = 30, $next_page_token = null)
    {
        list($response) = $this->reportChatSessionsWithHttpInfo($from, $to, $page_size, $next_page_token);
        return $response;
    }

    /**
     * Operation reportChatSessionsWithHttpInfo
     *
     * Get chat sessions reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportChatSessions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportChatSessionsWithHttpInfo($from, $to, $page_size = 30, $next_page_token = null)
    {
        $request = $this->reportChatSessionsRequest($from, $to, $page_size, $next_page_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportChatSessions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportChatSessions200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportChatSessions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportChatSessions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportChatSessions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportChatSessionsAsync
     *
     * Get chat sessions reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportChatSessionsAsync($from, $to, $page_size = 30, $next_page_token = null)
    {
        return $this->reportChatSessionsAsyncWithHttpInfo($from, $to, $page_size, $next_page_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportChatSessionsAsyncWithHttpInfo
     *
     * Get chat sessions reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportChatSessionsAsyncWithHttpInfo($from, $to, $page_size = 30, $next_page_token = null)
    {
        $returnType = '\Zoom\Api\Model\ReportChatSessions200Response';
        $request = $this->reportChatSessionsRequest($from, $to, $page_size, $next_page_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportChatSessions'
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportChatSessionsRequest($from, $to, $page_size = 30, $next_page_token = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportChatSessions'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportChatSessions'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportChatSessions, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/chat/sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportCloudRecording
     *
     * Get cloud recording usage report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportCloudRecording200Response
     */
    public function reportCloudRecording($from, $to)
    {
        list($response) = $this->reportCloudRecordingWithHttpInfo($from, $to);
        return $response;
    }

    /**
     * Operation reportCloudRecordingWithHttpInfo
     *
     * Get cloud recording usage report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportCloudRecording200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportCloudRecordingWithHttpInfo($from, $to)
    {
        $request = $this->reportCloudRecordingRequest($from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportCloudRecording200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportCloudRecording200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportCloudRecording200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportCloudRecording200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportCloudRecording200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportCloudRecordingAsync
     *
     * Get cloud recording usage report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportCloudRecordingAsync($from, $to)
    {
        return $this->reportCloudRecordingAsyncWithHttpInfo($from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportCloudRecordingAsyncWithHttpInfo
     *
     * Get cloud recording usage report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportCloudRecordingAsyncWithHttpInfo($from, $to)
    {
        $returnType = '\Zoom\Api\Model\ReportCloudRecording200Response';
        $request = $this->reportCloudRecordingRequest($from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportCloudRecording'
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportCloudRecordingRequest($from, $to)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportCloudRecording'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportCloudRecording'
            );
        }

        $resourcePath = '/report/cloud_recording';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportDaily
     *
     * Get daily usage report
     *
     * @param  int $year Year for this report (optional)
     * @param  int $month Month for this report (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportDaily200Response
     */
    public function reportDaily($year = null, $month = null)
    {
        list($response) = $this->reportDailyWithHttpInfo($year, $month);
        return $response;
    }

    /**
     * Operation reportDailyWithHttpInfo
     *
     * Get daily usage report
     *
     * @param  int $year Year for this report (optional)
     * @param  int $month Month for this report (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportDaily200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportDailyWithHttpInfo($year = null, $month = null)
    {
        $request = $this->reportDailyRequest($year, $month);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportDaily200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportDaily200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportDaily200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportDaily200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportDaily200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportDailyAsync
     *
     * Get daily usage report
     *
     * @param  int $year Year for this report (optional)
     * @param  int $month Month for this report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportDailyAsync($year = null, $month = null)
    {
        return $this->reportDailyAsyncWithHttpInfo($year, $month)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportDailyAsyncWithHttpInfo
     *
     * Get daily usage report
     *
     * @param  int $year Year for this report (optional)
     * @param  int $month Month for this report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportDailyAsyncWithHttpInfo($year = null, $month = null)
    {
        $returnType = '\Zoom\Api\Model\ReportDaily200Response';
        $request = $this->reportDailyRequest($year, $month);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportDaily'
     *
     * @param  int $year Year for this report (optional)
     * @param  int $month Month for this report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportDailyRequest($year = null, $month = null)
    {

        $resourcePath = '/report/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $month,
            'month', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportMeetingDetails
     *
     * Get meeting detail reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportMeetingDetails200Response
     */
    public function reportMeetingDetails($meeting_id)
    {
        list($response) = $this->reportMeetingDetailsWithHttpInfo($meeting_id);
        return $response;
    }

    /**
     * Operation reportMeetingDetailsWithHttpInfo
     *
     * Get meeting detail reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportMeetingDetails200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportMeetingDetailsWithHttpInfo($meeting_id)
    {
        $request = $this->reportMeetingDetailsRequest($meeting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportMeetingDetails200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportMeetingDetails200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportMeetingDetails200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportMeetingDetails200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportMeetingDetails200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportMeetingDetailsAsync
     *
     * Get meeting detail reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingDetailsAsync($meeting_id)
    {
        return $this->reportMeetingDetailsAsyncWithHttpInfo($meeting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportMeetingDetailsAsyncWithHttpInfo
     *
     * Get meeting detail reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingDetailsAsyncWithHttpInfo($meeting_id)
    {
        $returnType = '\Zoom\Api\Model\ReportMeetingDetails200Response';
        $request = $this->reportMeetingDetailsRequest($meeting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportMeetingDetails'
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportMeetingDetailsRequest($meeting_id)
    {
        // verify the required parameter 'meeting_id' is set
        if ($meeting_id === null || (is_array($meeting_id) && count($meeting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meeting_id when calling reportMeetingDetails'
            );
        }

        $resourcePath = '/report/meetings/{meetingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($meeting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'meetingId' . '}',
                ObjectSerializer::toPathValue($meeting_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportMeetingParticipants
     *
     * Get meeting participant reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields Provide &#x60;registrant_id&#x60; as the value for this field if you would like to see the registrant ID attribute in the response of this API call. A registrant ID is a unique identifier of a [meeting registrant](/docs/api-reference/zoom-api/methods#operation/meetingRegistrants). (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportMeetingParticipants200Response
     */
    public function reportMeetingParticipants($meeting_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        list($response) = $this->reportMeetingParticipantsWithHttpInfo($meeting_id, $page_size, $next_page_token, $include_fields);
        return $response;
    }

    /**
     * Operation reportMeetingParticipantsWithHttpInfo
     *
     * Get meeting participant reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields Provide &#x60;registrant_id&#x60; as the value for this field if you would like to see the registrant ID attribute in the response of this API call. A registrant ID is a unique identifier of a [meeting registrant](/docs/api-reference/zoom-api/methods#operation/meetingRegistrants). (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportMeetingParticipants200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportMeetingParticipantsWithHttpInfo($meeting_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        $request = $this->reportMeetingParticipantsRequest($meeting_id, $page_size, $next_page_token, $include_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportMeetingParticipants200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportMeetingParticipants200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportMeetingParticipants200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportMeetingParticipants200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportMeetingParticipants200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportMeetingParticipantsAsync
     *
     * Get meeting participant reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields Provide &#x60;registrant_id&#x60; as the value for this field if you would like to see the registrant ID attribute in the response of this API call. A registrant ID is a unique identifier of a [meeting registrant](/docs/api-reference/zoom-api/methods#operation/meetingRegistrants). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingParticipantsAsync($meeting_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        return $this->reportMeetingParticipantsAsyncWithHttpInfo($meeting_id, $page_size, $next_page_token, $include_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportMeetingParticipantsAsyncWithHttpInfo
     *
     * Get meeting participant reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields Provide &#x60;registrant_id&#x60; as the value for this field if you would like to see the registrant ID attribute in the response of this API call. A registrant ID is a unique identifier of a [meeting registrant](/docs/api-reference/zoom-api/methods#operation/meetingRegistrants). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingParticipantsAsyncWithHttpInfo($meeting_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        $returnType = '\Zoom\Api\Model\ReportMeetingParticipants200Response';
        $request = $this->reportMeetingParticipantsRequest($meeting_id, $page_size, $next_page_token, $include_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportMeetingParticipants'
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields Provide &#x60;registrant_id&#x60; as the value for this field if you would like to see the registrant ID attribute in the response of this API call. A registrant ID is a unique identifier of a [meeting registrant](/docs/api-reference/zoom-api/methods#operation/meetingRegistrants). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportMeetingParticipantsRequest($meeting_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        // verify the required parameter 'meeting_id' is set
        if ($meeting_id === null || (is_array($meeting_id) && count($meeting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meeting_id when calling reportMeetingParticipants'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportMeetingParticipants, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/meetings/{meetingId}/participants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_fields,
            'include_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($meeting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'meetingId' . '}',
                ObjectSerializer::toPathValue($meeting_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportMeetingPolls
     *
     * Get meeting poll reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportMeetingPolls200Response
     */
    public function reportMeetingPolls($meeting_id)
    {
        list($response) = $this->reportMeetingPollsWithHttpInfo($meeting_id);
        return $response;
    }

    /**
     * Operation reportMeetingPollsWithHttpInfo
     *
     * Get meeting poll reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportMeetingPolls200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportMeetingPollsWithHttpInfo($meeting_id)
    {
        $request = $this->reportMeetingPollsRequest($meeting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportMeetingPolls200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportMeetingPolls200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportMeetingPolls200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportMeetingPolls200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportMeetingPolls200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportMeetingPollsAsync
     *
     * Get meeting poll reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingPollsAsync($meeting_id)
    {
        return $this->reportMeetingPollsAsyncWithHttpInfo($meeting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportMeetingPollsAsyncWithHttpInfo
     *
     * Get meeting poll reports
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingPollsAsyncWithHttpInfo($meeting_id)
    {
        $returnType = '\Zoom\Api\Model\ReportMeetingPolls200Response';
        $request = $this->reportMeetingPollsRequest($meeting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportMeetingPolls'
     *
     * @param  ListPastMeetingPollsMeetingIdParameter $meeting_id The meeting&#39;s ID or universally unique ID (UUID).  * If you provide a meeting ID, the API will return a response for the latest meeting instance.  * If you provide a meeting UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the meeting UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportMeetingPollsRequest($meeting_id)
    {
        // verify the required parameter 'meeting_id' is set
        if ($meeting_id === null || (is_array($meeting_id) && count($meeting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meeting_id when calling reportMeetingPolls'
            );
        }

        $resourcePath = '/report/meetings/{meetingId}/polls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($meeting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'meetingId' . '}',
                ObjectSerializer::toPathValue($meeting_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportMeetings
     *
     * Get meeting reports
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The meeting type to query for:  * &#x60;past&#x60;  All past meetings.  * &#x60;pastOne&#x60;  A single past user meeting.  * &#x60;pastJoined&#x60;  All past meetings the account&#39;s users hosted or joined. (optional, default to 'past')
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportMeetings200Response
     */
    public function reportMeetings($user_id, $from, $to, $page_size = 30, $next_page_token = null, $type = 'past')
    {
        list($response) = $this->reportMeetingsWithHttpInfo($user_id, $from, $to, $page_size, $next_page_token, $type);
        return $response;
    }

    /**
     * Operation reportMeetingsWithHttpInfo
     *
     * Get meeting reports
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The meeting type to query for:  * &#x60;past&#x60;  All past meetings.  * &#x60;pastOne&#x60;  A single past user meeting.  * &#x60;pastJoined&#x60;  All past meetings the account&#39;s users hosted or joined. (optional, default to 'past')
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportMeetings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportMeetingsWithHttpInfo($user_id, $from, $to, $page_size = 30, $next_page_token = null, $type = 'past')
    {
        $request = $this->reportMeetingsRequest($user_id, $from, $to, $page_size, $next_page_token, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportMeetings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportMeetings200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportMeetings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportMeetings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportMeetings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportMeetingsAsync
     *
     * Get meeting reports
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The meeting type to query for:  * &#x60;past&#x60;  All past meetings.  * &#x60;pastOne&#x60;  A single past user meeting.  * &#x60;pastJoined&#x60;  All past meetings the account&#39;s users hosted or joined. (optional, default to 'past')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingsAsync($user_id, $from, $to, $page_size = 30, $next_page_token = null, $type = 'past')
    {
        return $this->reportMeetingsAsyncWithHttpInfo($user_id, $from, $to, $page_size, $next_page_token, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportMeetingsAsyncWithHttpInfo
     *
     * Get meeting reports
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The meeting type to query for:  * &#x60;past&#x60;  All past meetings.  * &#x60;pastOne&#x60;  A single past user meeting.  * &#x60;pastJoined&#x60;  All past meetings the account&#39;s users hosted or joined. (optional, default to 'past')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportMeetingsAsyncWithHttpInfo($user_id, $from, $to, $page_size = 30, $next_page_token = null, $type = 'past')
    {
        $returnType = '\Zoom\Api\Model\ReportMeetings200Response';
        $request = $this->reportMeetingsRequest($user_id, $from, $to, $page_size, $next_page_token, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportMeetings'
     *
     * @param  GroupAdminsDeleteUserIdParameter $user_id The user ID or email address of the user. For user-level apps, pass the &#x60;me&#x60; value. (required)
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The meeting type to query for:  * &#x60;past&#x60;  All past meetings.  * &#x60;pastOne&#x60;  A single past user meeting.  * &#x60;pastJoined&#x60;  All past meetings the account&#39;s users hosted or joined. (optional, default to 'past')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportMeetingsRequest($user_id, $from, $to, $page_size = 30, $next_page_token = null, $type = 'past')
    {
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling reportMeetings'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportMeetings'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportMeetings'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportMeetings, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/users/{userId}/meetings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportOperationLogs
     *
     * Get operation logs report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $category_type **Optional**&lt;br&gt; Filter your response by a category type to see reports for a specific category. The value for this field can be one of the following:&lt;br&gt; &#x60;all&#x60;&lt;br&gt;&#x60;user&#x60;&lt;br&gt;&#x60;user_settings&#x60;&lt;br&gt;&#x60;account&#x60;&lt;br&gt;&#x60;billing&#x60;&lt;br&gt;&#x60;im&#x60;&lt;br&gt;&#x60;recording&#x60;&lt;br&gt;&#x60;phone_contacts&#x60;&lt;br&gt;&#x60;webinar&#x60;&lt;br&gt;&#x60;sub_account&#x60;&lt;br&gt;&#x60;role&#x60;&lt;br&gt;&#x60;zoom_rooms&#x60; (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportOperationLogs200Response
     */
    public function reportOperationLogs($from, $to, $page_size = 30, $next_page_token = null, $category_type = null)
    {
        list($response) = $this->reportOperationLogsWithHttpInfo($from, $to, $page_size, $next_page_token, $category_type);
        return $response;
    }

    /**
     * Operation reportOperationLogsWithHttpInfo
     *
     * Get operation logs report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $category_type **Optional**&lt;br&gt; Filter your response by a category type to see reports for a specific category. The value for this field can be one of the following:&lt;br&gt; &#x60;all&#x60;&lt;br&gt;&#x60;user&#x60;&lt;br&gt;&#x60;user_settings&#x60;&lt;br&gt;&#x60;account&#x60;&lt;br&gt;&#x60;billing&#x60;&lt;br&gt;&#x60;im&#x60;&lt;br&gt;&#x60;recording&#x60;&lt;br&gt;&#x60;phone_contacts&#x60;&lt;br&gt;&#x60;webinar&#x60;&lt;br&gt;&#x60;sub_account&#x60;&lt;br&gt;&#x60;role&#x60;&lt;br&gt;&#x60;zoom_rooms&#x60; (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportOperationLogs200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportOperationLogsWithHttpInfo($from, $to, $page_size = 30, $next_page_token = null, $category_type = null)
    {
        $request = $this->reportOperationLogsRequest($from, $to, $page_size, $next_page_token, $category_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportOperationLogs200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportOperationLogs200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportOperationLogs200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportOperationLogs200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportOperationLogs200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportOperationLogsAsync
     *
     * Get operation logs report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $category_type **Optional**&lt;br&gt; Filter your response by a category type to see reports for a specific category. The value for this field can be one of the following:&lt;br&gt; &#x60;all&#x60;&lt;br&gt;&#x60;user&#x60;&lt;br&gt;&#x60;user_settings&#x60;&lt;br&gt;&#x60;account&#x60;&lt;br&gt;&#x60;billing&#x60;&lt;br&gt;&#x60;im&#x60;&lt;br&gt;&#x60;recording&#x60;&lt;br&gt;&#x60;phone_contacts&#x60;&lt;br&gt;&#x60;webinar&#x60;&lt;br&gt;&#x60;sub_account&#x60;&lt;br&gt;&#x60;role&#x60;&lt;br&gt;&#x60;zoom_rooms&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportOperationLogsAsync($from, $to, $page_size = 30, $next_page_token = null, $category_type = null)
    {
        return $this->reportOperationLogsAsyncWithHttpInfo($from, $to, $page_size, $next_page_token, $category_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportOperationLogsAsyncWithHttpInfo
     *
     * Get operation logs report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $category_type **Optional**&lt;br&gt; Filter your response by a category type to see reports for a specific category. The value for this field can be one of the following:&lt;br&gt; &#x60;all&#x60;&lt;br&gt;&#x60;user&#x60;&lt;br&gt;&#x60;user_settings&#x60;&lt;br&gt;&#x60;account&#x60;&lt;br&gt;&#x60;billing&#x60;&lt;br&gt;&#x60;im&#x60;&lt;br&gt;&#x60;recording&#x60;&lt;br&gt;&#x60;phone_contacts&#x60;&lt;br&gt;&#x60;webinar&#x60;&lt;br&gt;&#x60;sub_account&#x60;&lt;br&gt;&#x60;role&#x60;&lt;br&gt;&#x60;zoom_rooms&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportOperationLogsAsyncWithHttpInfo($from, $to, $page_size = 30, $next_page_token = null, $category_type = null)
    {
        $returnType = '\Zoom\Api\Model\ReportOperationLogs200Response';
        $request = $this->reportOperationLogsRequest($from, $to, $page_size, $next_page_token, $category_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportOperationLogs'
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $category_type **Optional**&lt;br&gt; Filter your response by a category type to see reports for a specific category. The value for this field can be one of the following:&lt;br&gt; &#x60;all&#x60;&lt;br&gt;&#x60;user&#x60;&lt;br&gt;&#x60;user_settings&#x60;&lt;br&gt;&#x60;account&#x60;&lt;br&gt;&#x60;billing&#x60;&lt;br&gt;&#x60;im&#x60;&lt;br&gt;&#x60;recording&#x60;&lt;br&gt;&#x60;phone_contacts&#x60;&lt;br&gt;&#x60;webinar&#x60;&lt;br&gt;&#x60;sub_account&#x60;&lt;br&gt;&#x60;role&#x60;&lt;br&gt;&#x60;zoom_rooms&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportOperationLogsRequest($from, $to, $page_size = 30, $next_page_token = null, $category_type = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportOperationLogs'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportOperationLogs'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportOperationLogs, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/operationlogs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_type,
            'category_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportSignInSignOutActivities
     *
     * Get sign In / sign out activity report
     *
     * @param  \DateTime $from Start date for which you would like to view the activity logs report. Using the &#x60;from&#x60; and &#x60;to&#x60; parameters, specify a monthly date range for the report as the API only provides one month worth of data in one request. The specified date range should fall within the last six months. (optional)
     * @param  \DateTime $to End date up to which you would like to view the activity logs report. (optional)
     * @param  int $page_size The number of records to be returned within a single API call (optional)
     * @param  string $next_page_token Next page token is used to paginate through large result sets (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportSignInSignOutActivities200Response
     */
    public function reportSignInSignOutActivities($from = null, $to = null, $page_size = null, $next_page_token = null)
    {
        list($response) = $this->reportSignInSignOutActivitiesWithHttpInfo($from, $to, $page_size, $next_page_token);
        return $response;
    }

    /**
     * Operation reportSignInSignOutActivitiesWithHttpInfo
     *
     * Get sign In / sign out activity report
     *
     * @param  \DateTime $from Start date for which you would like to view the activity logs report. Using the &#x60;from&#x60; and &#x60;to&#x60; parameters, specify a monthly date range for the report as the API only provides one month worth of data in one request. The specified date range should fall within the last six months. (optional)
     * @param  \DateTime $to End date up to which you would like to view the activity logs report. (optional)
     * @param  int $page_size The number of records to be returned within a single API call (optional)
     * @param  string $next_page_token Next page token is used to paginate through large result sets (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportSignInSignOutActivities200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportSignInSignOutActivitiesWithHttpInfo($from = null, $to = null, $page_size = null, $next_page_token = null)
    {
        $request = $this->reportSignInSignOutActivitiesRequest($from, $to, $page_size, $next_page_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportSignInSignOutActivities200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportSignInSignOutActivities200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportSignInSignOutActivities200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportSignInSignOutActivities200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportSignInSignOutActivities200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportSignInSignOutActivitiesAsync
     *
     * Get sign In / sign out activity report
     *
     * @param  \DateTime $from Start date for which you would like to view the activity logs report. Using the &#x60;from&#x60; and &#x60;to&#x60; parameters, specify a monthly date range for the report as the API only provides one month worth of data in one request. The specified date range should fall within the last six months. (optional)
     * @param  \DateTime $to End date up to which you would like to view the activity logs report. (optional)
     * @param  int $page_size The number of records to be returned within a single API call (optional)
     * @param  string $next_page_token Next page token is used to paginate through large result sets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportSignInSignOutActivitiesAsync($from = null, $to = null, $page_size = null, $next_page_token = null)
    {
        return $this->reportSignInSignOutActivitiesAsyncWithHttpInfo($from, $to, $page_size, $next_page_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportSignInSignOutActivitiesAsyncWithHttpInfo
     *
     * Get sign In / sign out activity report
     *
     * @param  \DateTime $from Start date for which you would like to view the activity logs report. Using the &#x60;from&#x60; and &#x60;to&#x60; parameters, specify a monthly date range for the report as the API only provides one month worth of data in one request. The specified date range should fall within the last six months. (optional)
     * @param  \DateTime $to End date up to which you would like to view the activity logs report. (optional)
     * @param  int $page_size The number of records to be returned within a single API call (optional)
     * @param  string $next_page_token Next page token is used to paginate through large result sets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportSignInSignOutActivitiesAsyncWithHttpInfo($from = null, $to = null, $page_size = null, $next_page_token = null)
    {
        $returnType = '\Zoom\Api\Model\ReportSignInSignOutActivities200Response';
        $request = $this->reportSignInSignOutActivitiesRequest($from, $to, $page_size, $next_page_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportSignInSignOutActivities'
     *
     * @param  \DateTime $from Start date for which you would like to view the activity logs report. Using the &#x60;from&#x60; and &#x60;to&#x60; parameters, specify a monthly date range for the report as the API only provides one month worth of data in one request. The specified date range should fall within the last six months. (optional)
     * @param  \DateTime $to End date up to which you would like to view the activity logs report. (optional)
     * @param  int $page_size The number of records to be returned within a single API call (optional)
     * @param  string $next_page_token Next page token is used to paginate through large result sets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportSignInSignOutActivitiesRequest($from = null, $to = null, $page_size = null, $next_page_token = null)
    {

        $resourcePath = '/report/activities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportTelephone
     *
     * Get telephone reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Audio types:&lt;br&gt;&#x60;1&#x60; - Toll-free Call-in &amp; Call-out.&lt;br&gt;&#x60;2&#x60; - Toll &lt;br&gt; &#x60;3&#x60; - SIP Connected Audio (optional, default to '1')
     * @param  string $query_date_type The type of date to query:  * &#x60;start_time&#x60;  Query by call start time.  * &#x60;end_time&#x60;  Query by call end time.  * &#x60;meeting_start_time&#x60;  Query by meeting start time.  * &#x60;meeting_end_time&#x60;  Query by meeting end time.   This value defaults to &#x60;start_time&#x60;. (optional, default to 'start_time')
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. This field is **not** available if the &#x60;query_date_type&#x60; parameter is the &#x60;meeting_start_time&#x60; or &#x60;meeting_end_time&#x60; value.   This field is deprecated. Use the &#x60;next_page_token&#x60; query parameter for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportTelephone200Response
     */
    public function reportTelephone($from, $to, $type = '1', $query_date_type = 'start_time', $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        list($response) = $this->reportTelephoneWithHttpInfo($from, $to, $type, $query_date_type, $page_size, $page_number, $next_page_token);
        return $response;
    }

    /**
     * Operation reportTelephoneWithHttpInfo
     *
     * Get telephone reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Audio types:&lt;br&gt;&#x60;1&#x60; - Toll-free Call-in &amp; Call-out.&lt;br&gt;&#x60;2&#x60; - Toll &lt;br&gt; &#x60;3&#x60; - SIP Connected Audio (optional, default to '1')
     * @param  string $query_date_type The type of date to query:  * &#x60;start_time&#x60;  Query by call start time.  * &#x60;end_time&#x60;  Query by call end time.  * &#x60;meeting_start_time&#x60;  Query by meeting start time.  * &#x60;meeting_end_time&#x60;  Query by meeting end time.   This value defaults to &#x60;start_time&#x60;. (optional, default to 'start_time')
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. This field is **not** available if the &#x60;query_date_type&#x60; parameter is the &#x60;meeting_start_time&#x60; or &#x60;meeting_end_time&#x60; value.   This field is deprecated. Use the &#x60;next_page_token&#x60; query parameter for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportTelephone200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportTelephoneWithHttpInfo($from, $to, $type = '1', $query_date_type = 'start_time', $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        $request = $this->reportTelephoneRequest($from, $to, $type, $query_date_type, $page_size, $page_number, $next_page_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportTelephone200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportTelephone200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportTelephone200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportTelephone200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportTelephone200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportTelephoneAsync
     *
     * Get telephone reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Audio types:&lt;br&gt;&#x60;1&#x60; - Toll-free Call-in &amp; Call-out.&lt;br&gt;&#x60;2&#x60; - Toll &lt;br&gt; &#x60;3&#x60; - SIP Connected Audio (optional, default to '1')
     * @param  string $query_date_type The type of date to query:  * &#x60;start_time&#x60;  Query by call start time.  * &#x60;end_time&#x60;  Query by call end time.  * &#x60;meeting_start_time&#x60;  Query by meeting start time.  * &#x60;meeting_end_time&#x60;  Query by meeting end time.   This value defaults to &#x60;start_time&#x60;. (optional, default to 'start_time')
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. This field is **not** available if the &#x60;query_date_type&#x60; parameter is the &#x60;meeting_start_time&#x60; or &#x60;meeting_end_time&#x60; value.   This field is deprecated. Use the &#x60;next_page_token&#x60; query parameter for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportTelephoneAsync($from, $to, $type = '1', $query_date_type = 'start_time', $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        return $this->reportTelephoneAsyncWithHttpInfo($from, $to, $type, $query_date_type, $page_size, $page_number, $next_page_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportTelephoneAsyncWithHttpInfo
     *
     * Get telephone reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Audio types:&lt;br&gt;&#x60;1&#x60; - Toll-free Call-in &amp; Call-out.&lt;br&gt;&#x60;2&#x60; - Toll &lt;br&gt; &#x60;3&#x60; - SIP Connected Audio (optional, default to '1')
     * @param  string $query_date_type The type of date to query:  * &#x60;start_time&#x60;  Query by call start time.  * &#x60;end_time&#x60;  Query by call end time.  * &#x60;meeting_start_time&#x60;  Query by meeting start time.  * &#x60;meeting_end_time&#x60;  Query by meeting end time.   This value defaults to &#x60;start_time&#x60;. (optional, default to 'start_time')
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. This field is **not** available if the &#x60;query_date_type&#x60; parameter is the &#x60;meeting_start_time&#x60; or &#x60;meeting_end_time&#x60; value.   This field is deprecated. Use the &#x60;next_page_token&#x60; query parameter for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportTelephoneAsyncWithHttpInfo($from, $to, $type = '1', $query_date_type = 'start_time', $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        $returnType = '\Zoom\Api\Model\ReportTelephone200Response';
        $request = $this->reportTelephoneRequest($from, $to, $type, $query_date_type, $page_size, $page_number, $next_page_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportTelephone'
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Audio types:&lt;br&gt;&#x60;1&#x60; - Toll-free Call-in &amp; Call-out.&lt;br&gt;&#x60;2&#x60; - Toll &lt;br&gt; &#x60;3&#x60; - SIP Connected Audio (optional, default to '1')
     * @param  string $query_date_type The type of date to query:  * &#x60;start_time&#x60;  Query by call start time.  * &#x60;end_time&#x60;  Query by call end time.  * &#x60;meeting_start_time&#x60;  Query by meeting start time.  * &#x60;meeting_end_time&#x60;  Query by meeting end time.   This value defaults to &#x60;start_time&#x60;. (optional, default to 'start_time')
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. This field is **not** available if the &#x60;query_date_type&#x60; parameter is the &#x60;meeting_start_time&#x60; or &#x60;meeting_end_time&#x60; value.   This field is deprecated. Use the &#x60;next_page_token&#x60; query parameter for pagination. (optional, default to 1) (deprecated)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportTelephoneRequest($from, $to, $type = '1', $query_date_type = 'start_time', $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportTelephone'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportTelephone'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportTelephone, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/telephone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query_date_type,
            'query_date_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_number,
            'page_number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportUpcomingEvents
     *
     * Get upcoming events report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The type of event to query:  * &#x60;meeting&#x60;  A meeting event.  * &#x60;webinar&#x60;  A webinar event.  * &#x60;all&#x60;  Both meeting and webinar events.  This value defaults to &#x60;all&#x60;. (optional, default to 'all')
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportUpcomingEvents200Response
     */
    public function reportUpcomingEvents($from, $to, $page_size = 30, $next_page_token = null, $type = 'all')
    {
        list($response) = $this->reportUpcomingEventsWithHttpInfo($from, $to, $page_size, $next_page_token, $type);
        return $response;
    }

    /**
     * Operation reportUpcomingEventsWithHttpInfo
     *
     * Get upcoming events report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The type of event to query:  * &#x60;meeting&#x60;  A meeting event.  * &#x60;webinar&#x60;  A webinar event.  * &#x60;all&#x60;  Both meeting and webinar events.  This value defaults to &#x60;all&#x60;. (optional, default to 'all')
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportUpcomingEvents200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportUpcomingEventsWithHttpInfo($from, $to, $page_size = 30, $next_page_token = null, $type = 'all')
    {
        $request = $this->reportUpcomingEventsRequest($from, $to, $page_size, $next_page_token, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportUpcomingEvents200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportUpcomingEvents200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportUpcomingEvents200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportUpcomingEvents200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportUpcomingEvents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportUpcomingEventsAsync
     *
     * Get upcoming events report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The type of event to query:  * &#x60;meeting&#x60;  A meeting event.  * &#x60;webinar&#x60;  A webinar event.  * &#x60;all&#x60;  Both meeting and webinar events.  This value defaults to &#x60;all&#x60;. (optional, default to 'all')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportUpcomingEventsAsync($from, $to, $page_size = 30, $next_page_token = null, $type = 'all')
    {
        return $this->reportUpcomingEventsAsyncWithHttpInfo($from, $to, $page_size, $next_page_token, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportUpcomingEventsAsyncWithHttpInfo
     *
     * Get upcoming events report
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The type of event to query:  * &#x60;meeting&#x60;  A meeting event.  * &#x60;webinar&#x60;  A webinar event.  * &#x60;all&#x60;  Both meeting and webinar events.  This value defaults to &#x60;all&#x60;. (optional, default to 'all')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportUpcomingEventsAsyncWithHttpInfo($from, $to, $page_size = 30, $next_page_token = null, $type = 'all')
    {
        $returnType = '\Zoom\Api\Model\ReportUpcomingEvents200Response';
        $request = $this->reportUpcomingEventsRequest($from, $to, $page_size, $next_page_token, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportUpcomingEvents'
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $type The type of event to query:  * &#x60;meeting&#x60;  A meeting event.  * &#x60;webinar&#x60;  A webinar event.  * &#x60;all&#x60;  Both meeting and webinar events.  This value defaults to &#x60;all&#x60;. (optional, default to 'all')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportUpcomingEventsRequest($from, $to, $page_size = 30, $next_page_token = null, $type = 'all')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportUpcomingEvents'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportUpcomingEvents'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportUpcomingEvents, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/upcoming_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportUsers
     *
     * Get active/inactive host reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Active or inactive hosts.&lt;br&gt;&#x60;active&#x60; - Active hosts. &lt;br&gt;&#x60;inactive&#x60; - Inactive hosts. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. (optional, default to 1)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportUsers200Response
     */
    public function reportUsers($from, $to, $type = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        list($response) = $this->reportUsersWithHttpInfo($from, $to, $type, $page_size, $page_number, $next_page_token);
        return $response;
    }

    /**
     * Operation reportUsersWithHttpInfo
     *
     * Get active/inactive host reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Active or inactive hosts.&lt;br&gt;&#x60;active&#x60; - Active hosts. &lt;br&gt;&#x60;inactive&#x60; - Inactive hosts. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. (optional, default to 1)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportUsers200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportUsersWithHttpInfo($from, $to, $type = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        $request = $this->reportUsersRequest($from, $to, $type, $page_size, $page_number, $next_page_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportUsers200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportUsers200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportUsers200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportUsers200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportUsers200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportUsersAsync
     *
     * Get active/inactive host reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Active or inactive hosts.&lt;br&gt;&#x60;active&#x60; - Active hosts. &lt;br&gt;&#x60;inactive&#x60; - Inactive hosts. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. (optional, default to 1)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportUsersAsync($from, $to, $type = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        return $this->reportUsersAsyncWithHttpInfo($from, $to, $type, $page_size, $page_number, $next_page_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportUsersAsyncWithHttpInfo
     *
     * Get active/inactive host reports
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Active or inactive hosts.&lt;br&gt;&#x60;active&#x60; - Active hosts. &lt;br&gt;&#x60;inactive&#x60; - Inactive hosts. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. (optional, default to 1)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportUsersAsyncWithHttpInfo($from, $to, $type = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        $returnType = '\Zoom\Api\Model\ReportUsers200Response';
        $request = $this->reportUsersRequest($from, $to, $type, $page_size, $page_number, $next_page_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportUsers'
     *
     * @param  \DateTime $from Start date in &#39;yyyy-mm-dd&#39; format. The date range defined by the \&quot;from\&quot; and \&quot;to\&quot; parameters should only be one month as the report includes only one month worth of data at once. (required)
     * @param  \DateTime $to End date. (required)
     * @param  string $type Active or inactive hosts.&lt;br&gt;&#x60;active&#x60; - Active hosts. &lt;br&gt;&#x60;inactive&#x60; - Inactive hosts. (optional)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  int $page_number The page number of the current page in the returned records. (optional, default to 1)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportUsersRequest($from, $to, $type = null, $page_size = 30, $page_number = 1, $next_page_token = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling reportUsers'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling reportUsers'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportUsers, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_number,
            'page_number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportWebinarDetails
     *
     * Get webinar detail reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportWebinarDetails200Response
     */
    public function reportWebinarDetails($webinar_id)
    {
        list($response) = $this->reportWebinarDetailsWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation reportWebinarDetailsWithHttpInfo
     *
     * Get webinar detail reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportWebinarDetails200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportWebinarDetailsWithHttpInfo($webinar_id)
    {
        $request = $this->reportWebinarDetailsRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportWebinarDetails200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportWebinarDetails200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportWebinarDetails200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportWebinarDetails200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportWebinarDetails200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportWebinarDetailsAsync
     *
     * Get webinar detail reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarDetailsAsync($webinar_id)
    {
        return $this->reportWebinarDetailsAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportWebinarDetailsAsyncWithHttpInfo
     *
     * Get webinar detail reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarDetailsAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\Zoom\Api\Model\ReportWebinarDetails200Response';
        $request = $this->reportWebinarDetailsRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportWebinarDetails'
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportWebinarDetailsRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling reportWebinarDetails'
            );
        }

        $resourcePath = '/report/webinars/{webinarId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportWebinarParticipants
     *
     * Get webinar participant reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields The additional query parameters to include:  * &#x60;registrant_id&#x60;  Include the registrant&#39;s ID in the API response. The registrant ID is the webinar participant&#39;s unique ID. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportWebinarParticipants200Response
     */
    public function reportWebinarParticipants($webinar_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        list($response) = $this->reportWebinarParticipantsWithHttpInfo($webinar_id, $page_size, $next_page_token, $include_fields);
        return $response;
    }

    /**
     * Operation reportWebinarParticipantsWithHttpInfo
     *
     * Get webinar participant reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields The additional query parameters to include:  * &#x60;registrant_id&#x60;  Include the registrant&#39;s ID in the API response. The registrant ID is the webinar participant&#39;s unique ID. (optional)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportWebinarParticipants200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportWebinarParticipantsWithHttpInfo($webinar_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        $request = $this->reportWebinarParticipantsRequest($webinar_id, $page_size, $next_page_token, $include_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportWebinarParticipants200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportWebinarParticipants200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportWebinarParticipants200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportWebinarParticipants200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportWebinarParticipants200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportWebinarParticipantsAsync
     *
     * Get webinar participant reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields The additional query parameters to include:  * &#x60;registrant_id&#x60;  Include the registrant&#39;s ID in the API response. The registrant ID is the webinar participant&#39;s unique ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarParticipantsAsync($webinar_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        return $this->reportWebinarParticipantsAsyncWithHttpInfo($webinar_id, $page_size, $next_page_token, $include_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportWebinarParticipantsAsyncWithHttpInfo
     *
     * Get webinar participant reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields The additional query parameters to include:  * &#x60;registrant_id&#x60;  Include the registrant&#39;s ID in the API response. The registrant ID is the webinar participant&#39;s unique ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarParticipantsAsyncWithHttpInfo($webinar_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        $returnType = '\Zoom\Api\Model\ReportWebinarParticipants200Response';
        $request = $this->reportWebinarParticipantsRequest($webinar_id, $page_size, $next_page_token, $include_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportWebinarParticipants'
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     * @param  int $page_size The number of records returned within a single API call. (optional, default to 30)
     * @param  string $next_page_token The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes. (optional)
     * @param  string $include_fields The additional query parameters to include:  * &#x60;registrant_id&#x60;  Include the registrant&#39;s ID in the API response. The registrant ID is the webinar participant&#39;s unique ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportWebinarParticipantsRequest($webinar_id, $page_size = 30, $next_page_token = null, $include_fields = null)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling reportWebinarParticipants'
            );
        }
        if ($page_size !== null && $page_size > 300) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ReportsApi.reportWebinarParticipants, must be smaller than or equal to 300.');
        }


        $resourcePath = '/report/webinars/{webinarId}/participants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_page_token,
            'next_page_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_fields,
            'include_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportWebinarPolls
     *
     * Get webinar poll reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportWebinarPolls200Response
     */
    public function reportWebinarPolls($webinar_id)
    {
        list($response) = $this->reportWebinarPollsWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation reportWebinarPollsWithHttpInfo
     *
     * Get webinar poll reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportWebinarPolls200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportWebinarPollsWithHttpInfo($webinar_id)
    {
        $request = $this->reportWebinarPollsRequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportWebinarPolls200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportWebinarPolls200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportWebinarPolls200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportWebinarPolls200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportWebinarPolls200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportWebinarPollsAsync
     *
     * Get webinar poll reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarPollsAsync($webinar_id)
    {
        return $this->reportWebinarPollsAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportWebinarPollsAsyncWithHttpInfo
     *
     * Get webinar poll reports
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarPollsAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\Zoom\Api\Model\ReportWebinarPolls200Response';
        $request = $this->reportWebinarPollsRequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportWebinarPolls'
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportWebinarPollsRequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling reportWebinarPolls'
            );
        }

        $resourcePath = '/report/webinars/{webinarId}/polls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportWebinarQA
     *
     * Get webinar Q&amp;A report
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zoom\Api\Model\ReportWebinarQA200Response
     */
    public function reportWebinarQA($webinar_id)
    {
        list($response) = $this->reportWebinarQAWithHttpInfo($webinar_id);
        return $response;
    }

    /**
     * Operation reportWebinarQAWithHttpInfo
     *
     * Get webinar Q&amp;A report
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \Zoom\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zoom\Api\Model\ReportWebinarQA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportWebinarQAWithHttpInfo($webinar_id)
    {
        $request = $this->reportWebinarQARequest($webinar_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Zoom\Api\Model\ReportWebinarQA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Zoom\Api\Model\ReportWebinarQA200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Zoom\Api\Model\ReportWebinarQA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Zoom\Api\Model\ReportWebinarQA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zoom\Api\Model\ReportWebinarQA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportWebinarQAAsync
     *
     * Get webinar Q&amp;A report
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarQAAsync($webinar_id)
    {
        return $this->reportWebinarQAAsyncWithHttpInfo($webinar_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportWebinarQAAsyncWithHttpInfo
     *
     * Get webinar Q&amp;A report
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportWebinarQAAsyncWithHttpInfo($webinar_id)
    {
        $returnType = '\Zoom\Api\Model\ReportWebinarQA200Response';
        $request = $this->reportWebinarQARequest($webinar_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportWebinarQA'
     *
     * @param  string $webinar_id The webinar&#39;s ID or universally unique ID (UUID).  * If you provide a webinar ID, the API will return a response for the latest webinar instance.  * If you provide a webinar UUID that begins with a &#x60;/&#x60; character or contains the &#x60;//&#x60; characters, you **must** double-encode the webinar UUID before making an API request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportWebinarQARequest($webinar_id)
    {
        // verify the required parameter 'webinar_id' is set
        if ($webinar_id === null || (is_array($webinar_id) && count($webinar_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webinar_id when calling reportWebinarQA'
            );
        }

        $resourcePath = '/report/webinars/{webinarId}/qa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webinar_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webinarId' . '}',
                ObjectSerializer::toPathValue($webinar_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
